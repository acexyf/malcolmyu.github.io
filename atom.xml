<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>malcolm-blog</title>
  <subtitle>魔法师学徒</subtitle>
  <link href="/malnote/atom.xml" rel="self"/>
  
  <link href="http://malcolmyu.github.io/malnote/"/>
  <updated>2016-05-29T06:45:47.000Z</updated>
  <id>http://malcolmyu.github.io/malnote/</id>
  
  <author>
    <name>malcolm yu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redux 从无到有</title>
    <link href="http://malcolmyu.github.io/malnote/2016/04/16/Redux-Zero-to-One/"/>
    <id>http://malcolmyu.github.io/malnote/2016/04/16/Redux-Zero-to-One/</id>
    <published>2016-04-15T16:00:00.000Z</published>
    <updated>2016-05-29T06:45:47.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xinjg.com1.z0.glb.clouddn.com/redux-and-angularjs-redux-arch.jpg&quot; alt=&quot;redux 图示&quot;&gt;&lt;/p&gt;
&lt;p&gt;redux 自诞生之日就被冠以『学习曲线陡峭』之名，让学习者望而却步。然而由于工作需要，最近还是硬着头皮把 redux 的这一套研究了一番，发现传说中陡峭的学习曲线好像也没有那么夸张，我们甚至可以从零开始实现一个基础版本的 redux。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;基础版本&quot;&gt;基础版本&lt;/h1&gt;&lt;p&gt;设想一下，我们每天沉浸在复杂项目繁琐的开发之中，每天都在处理页面上的各种数据流动。比如我们做一个成绩单项目，可以在页面中发送 ajax 请求，然后用请求之后的数据渲染页面上的分数；亦或我们的页面使用了双向绑定，在用户输入发生变化的时候，页面分数就会自动发生改变。由于数据的来源多种多样，我们觉得数据的管理有必要单独抽取出来进行统一处理。&lt;/p&gt;
&lt;p&gt;于是我们果断手工撸了以下代码：&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;jsbin-embed&quot; href=&quot;http://jsbin.com/difoza/embed?js,output&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JS Bin on jsbin.com&lt;/a&gt;&lt;script src=&quot;http://static.jsbin.com/js/embed.min.js?3.35.12&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;上面就是 redux 的基本实现，&lt;del&gt;好了本次的讲解结束了，谢谢大家&lt;/del&gt; 在这个例子中，我们进行了以下尝试：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;抽象数据层。&lt;/strong&gt;我们将数据部分抽取出来进行统一管理，在页面层面我们使用 action 发送前端存在且受用户影响的数据；数据怎么处理，交给调度器 dispacher 解决；最终数据流向 store 对象（这里就是组件的 &lt;code&gt;state&lt;/code&gt;）进行存储，并最终展现在页面某模块上。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;固定数据流。&lt;/strong&gt;我们保证数据流向永远是：action → dispacher → store → view，明确且清晰。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;事实上，上面两点就是 flux 体系带给我们的；而 redux 作为 flux 的一种实现，尽管略显不同，但他还是很好的体现了 flux 体系的本质。&lt;/p&gt;
&lt;h1 id=&quot;构建_store&quot;&gt;构建 store&lt;/h1&gt;&lt;p&gt;然而上面的例子还是依赖于 react，我们需要将手工实现的粗糙的 redux 模块独立出来，使用 flux 里的发布/订阅概念来完成这一行为。也就是说，我们要构建出一个独立的 store。它拥有保存状态、订阅事件、发布事件等一系列功能，脱离了 react 体系也能独立工作。&lt;/p&gt;
&lt;p&gt;对于这个函数，需要传入两个参数，第一个是具体的调度方法 &lt;code&gt;dispatcher&lt;/code&gt;，第二个是初始的状态 &lt;code&gt;initialState&lt;/code&gt;。然后它使用闭包来保持状态，对外提供三个方法，分别是获取状态的方法 &lt;code&gt;getState()&lt;/code&gt;、发布方法 &lt;code&gt;publish()&lt;/code&gt; 以及订阅方法 &lt;code&gt;subscribe()&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createStore&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;dispatcher, initialState&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; currentState = initialState;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; listeners = [];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getState&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; currentState;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 订阅方法，注册回调，当状态发生改变时可以及时响应&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;subscribe&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 发布方法，由用户调用，发布对状态进行的改变&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;publish&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们分析一下订阅方法，实际上其功能有点类似于 &lt;code&gt;$.Callback&lt;/code&gt;，就是注册一堆回调函数，然后在发布的时候依次执行；而发布方法无非就是执行用户传入的调度函数，然后出发一下之前由订阅方法注册的回调。我们为这两个方法加入代码：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;subscribe&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;listener&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    listeners.push(listener);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;publish&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;action&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    currentState = dispatcher(currentState, action);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    listeners.forEach(listener =&amp;gt; listener());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; action;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后我们对上面的例子使用 &lt;code&gt;createStore&lt;/code&gt; 方法进行一个升级：&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;jsbin-embed&quot; href=&quot;http://jsbin.com/lalube/embed?js,output&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JS Bin on jsbin.com&lt;/a&gt;&lt;script src=&quot;http://static.jsbin.com/js/embed.min.js?3.35.12&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;如此神奇，感觉离 redux 更近了一步呢！&lt;/p&gt;
&lt;h1 id=&quot;复杂数据结构&quot;&gt;复杂数据结构&lt;/h1&gt;&lt;p&gt;然而上面的例子仅仅是一个简单的数据结构，不足以体现出 redux 的伟大之处。假如我们增加一个 action，然后给 state 增加一个叫 &lt;code&gt;students&lt;/code&gt; 的数据表示学生人数，这时候应该怎么处理呢？&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;jsbin-embed&quot; href=&quot;http://jsbin.com/qetani/embed?js,output&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JS Bin on jsbin.com&lt;/a&gt;&lt;script src=&quot;http://static.jsbin.com/js/embed.min.js?3.35.12&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;聪明如你可能很快就会想到，我们给 &lt;code&gt;action&lt;/code&gt; 加一个 &lt;code&gt;type&lt;/code&gt; 字段来处理嘛！肥肠好，但是设想一下，如果我们的 store 非常复杂，那用户的 &lt;code&gt;dispatcher&lt;/code&gt; 和 &lt;code&gt;state&lt;/code&gt; 岂不是成了一大坨？如果有两个 action 具体行为差不多，但是有细微的不同，那 &lt;code&gt;dispatcher&lt;/code&gt; 怎么复用呢？这个时候我们就遇到了 flux 体系结构的第一个问题：&lt;strong&gt;复杂的 store 难以管理，可复用性差&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这时，天纵英才的丹爷提出了一个概念：&lt;strong&gt;使用 reducer&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;直到这里我们才开始脱离 flux，进入 redux 的思维领域。我们知道 js 里有一个函数叫 &lt;code&gt;reducer&lt;/code&gt;，这是一个神奇的函数，经常会有意想不到的妙用。如不用 &lt;code&gt;reverse&lt;/code&gt; 如何反转一个数组？用 &lt;code&gt;reduce&lt;/code&gt; 就可以轻松完成：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;arr.reduce((a, b) =&amp;gt; [b].concat(a), []);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;说白了，&lt;code&gt;reduce&lt;/code&gt; 干的事情就是用一个初始值遍历一个数组，然后获取最终结果。这其实与我们现在的 &lt;code&gt;dispatcher&lt;/code&gt; 很像：我们使用一个最初的状态遍历所有的 &lt;code&gt;dispatcher&lt;/code&gt;，然后获取最终的状态。所以我们干脆直接将这种调度器称为 &lt;code&gt;reducer&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;你说这只是改了个名字嘛，好像也没什么了不起。然而并不是这样，改成 &lt;code&gt;reducer&lt;/code&gt; 之后，调度器就有了&lt;strong&gt;可嵌套（nested）&lt;/strong&gt;功能。我们之前的调度器用的仅仅是 &lt;code&gt;switch...case&lt;/code&gt; 语句，而到了 &lt;code&gt;reducer&lt;/code&gt; 这里，我们使用了一系列函数对象。可以说，如果我们用&lt;strong&gt;状态树&lt;/strong&gt;来形容 store 中存储的结构的话，那么 reducer 就是树的叶子节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xinjg.com1.z0.glb.clouddn.com/combined-redux.png&quot; alt=&quot;combined-redux&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到，一个普通的状态树实际上是由多个连接过的 reducer 构成，其中连接的过程也会给状态树添加新的属性。比如我们初始的状态是空对象 &lt;code&gt;{}&lt;/code&gt;，然后我们拥有 3 个 reducer：&lt;code&gt;r1&lt;/code&gt; &lt;code&gt;r2&lt;/code&gt; &lt;code&gt;r3&lt;/code&gt;，假如我们想让前两个 reducer 结合起来，和 &lt;code&gt;r3&lt;/code&gt; 并列，我们可以使用某种手段将 &lt;code&gt;r1&lt;/code&gt; &lt;code&gt;r2&lt;/code&gt; 组合成 &lt;code&gt;c1&lt;/code&gt;，然后将 &lt;code&gt;c1&lt;/code&gt; 和 &lt;code&gt;r3&lt;/code&gt; 组合成最终的状态。那么最终的状态就是如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    c1: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        r1: initialStateOfR1,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        r2: initialStateOfR2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    r3: initialStateOfR3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们可以认为最终中间件的结合手段是&lt;strong&gt;递归&lt;/strong&gt;的：结合之后的 &lt;code&gt;combined reducer&lt;/code&gt; 只是深度更深了一层，实际上与 &lt;code&gt;reducer&lt;/code&gt; 效用一致。我们来手动实现一个结合函数 &lt;code&gt;combineReducer&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;combineReducer&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;reducers&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; reducerKeys = &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.keys(reducers);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;combine&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;state = &amp;#123;&amp;#125;, action&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; nextState = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        reducerKeys.forEach(key =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; reducer = reducers[key];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; previous = state[key];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; next = reducer(previous, action);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            nextState[key] = next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; nextState;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们把这个函数添加到之前的例子上，然后增加一个 reducer，使得这个例子变得复杂：&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;jsbin-embed&quot; href=&quot;http://jsbin.com/nuvaxax/embed?js,output&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JS Bin on jsbin.com&lt;/a&gt;&lt;script src=&quot;http://static.jsbin.com/js/embed.min.js?3.35.12&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;碉堡了，我们的国产 &lt;code&gt;redux&lt;/code&gt; 已经有递归 &lt;code&gt;reducer&lt;/code&gt; 了！还有什么能难倒我们？这时产品走了过来：『旁友，我们这儿有个变更，请把文科、理科分数改成异步获取的。嗯，我不管怎么实现，今天能搞定吗？』&lt;/p&gt;
&lt;p&gt;虽然很不情愿，但是我们还是哼哧哼哧的改了起来。js 的哪一种异步我没有写过？分分钟就来了个异步写法：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;showScienceScore() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 手动搞成异步的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; score = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;(resolve =&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        setTimeout(() =&amp;gt; resolve([&lt;span class=&quot;number&quot;&gt;90&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;86&lt;/span&gt;]), &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    score.then(data =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; [math, physics] = data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	   &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.store.publish(getScienceScore(math, physics))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;【详细写一下，改 publish 为 dispatch】&lt;/p&gt;
&lt;p&gt;是的，这样确实可以搞定，可是岂不是意味着两个分数就得写两个 promise，100 个异步请求岂不是得写 100 个 promise？之前我们或许确实是这样搞的，那主要是因为我们后续的操作并不统一；但在 &lt;code&gt;redux&lt;/code&gt; 里完全不同，我们进行状态更改的手段都是 &lt;code&gt;dispatch&lt;/code&gt; 函数，进行数据处理的都是 &lt;code&gt;reducer&lt;/code&gt;，所以我们可以直接对 &lt;code&gt;dispatch&lt;/code&gt; 进行修改以达到异步目的！而这个修改手段就是所谓的&lt;strong&gt;中间件&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&quot;使用中间件&quot;&gt;使用中间件&lt;/h1&gt;&lt;h2 id=&quot;什么是中间件&quot;&gt;什么是中间件&lt;/h2&gt;&lt;p&gt;中间件实际上就是之前一种 Monkey Patch 的写法，比如我们想给一个作为属性的函数加上打印日志的功能，又不想改变函数名称，可以这么搞：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj = &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    foo: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;foo!&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; originFoo = obj.foo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj.foo = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;...args&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;begin&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    originFoo.apply(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;end&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj.foo();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// begin&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// foo!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不过这么写有点毛，每次还得搞一个变量。有了上面 &lt;code&gt;combineReducer&lt;/code&gt; 的函数式编程经验，我们把这种 Monkey Patch 直接搞成函数嵌套，用闭包来保存函数，就感觉&lt;del&gt;有逼格&lt;/del&gt;优雅多了：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;patchLog&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;...args&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;begin&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        obj.func.apply(obj, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;end&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj.foo = patchLog(obj);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是，上面的例子考虑很多处理函数参数和作用域的问题，然而对于我们的 &lt;code&gt;dispatch&lt;/code&gt; 函数来说，它的参数和作用域都是固定的，所以写起来会更简单一点。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;patchLog&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;store&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 使用闭包保护之前的 dispatch 函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; dispatch = store.dispatch;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;action&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;begin&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dispatch(action);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;end&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;store.dispatch = patchLog(store);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;next_登场&quot;&gt;next 登场&lt;/h2&gt;&lt;p&gt;然而上文的 &lt;code&gt;let dispatch = store.dispatch&lt;/code&gt; 感觉还是不够友好，使用者每次还得记着把 &lt;code&gt;dispatch&lt;/code&gt; 拿出来存一下，不然就变成无限循环调用了。既然都函数式编程了，果断再搞一层，用传参数的方式把 &lt;code&gt;dispatch&lt;/code&gt; 传进来，尽然都中间件了，就叫它 &lt;code&gt;next&lt;/code&gt; 吧：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;patchLog&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;store&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;next&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;action&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;begin&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            next(action);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;end&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 用上 ES6 的箭头函数，逼格在我体内流动&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; patchLog = store =&amp;gt; next =&amp;gt; action =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;begin&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    next(action);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;end&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 再写一个中间件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; patchTimer = store =&amp;gt; next =&amp;gt; action =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;begin time&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    next(action);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;end time&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;store.dispatch = patchLog(store)(store.dispatch);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;store.dispatch = patchTimer(store)(store.dispatch);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里我们可以看到，每一层的 &lt;code&gt;next&lt;/code&gt; 都表示后续包裹的 &lt;code&gt;dispatch&lt;/code&gt; 函数，调用了就表示继续执行下面的中间键。&lt;/p&gt;
&lt;p&gt;啥，你说为什么还要传 &lt;code&gt;store&lt;/code&gt;？好问题，有两个原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;store&lt;/code&gt; 又不止 &lt;code&gt;dispatch&lt;/code&gt; 一个属性，传了它以后还可以用 &lt;code&gt;getState&lt;/code&gt; 看看当前存了什么状态；&lt;/li&gt;
&lt;li&gt;提供了一种&lt;strong&gt;阻断中间件的方式&lt;/strong&gt;：这个很重要，现在不着急说，下文我会表态的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;&lt;p&gt;但是这么整解决不了两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;感觉有点 low 啊，每次都一遍一遍的写参数，我感觉很难受；&lt;/li&gt;
&lt;li&gt;用户在中间件里调用 &lt;code&gt;store.dispatch&lt;/code&gt;，不是又死循环了么？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一个好办，刚才那样写太恶心，那我们这样写，就好看多了：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;applyMiddleware(patchLog, patchTimer)(store);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这就意味着 &lt;code&gt;applyMiddleware&lt;/code&gt; 要把整个 patch 串联起来，然后把最后套了无数层的函数赋值给 &lt;code&gt;store.dispatch&lt;/code&gt;。来我们手动撸一下这个实现：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;applyMiddleware&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;...middlewares&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (store) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 注意中间件的执行顺序，是 reduceRight&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        store.dispatch = middlewares.reduceRight((next, middleware) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; middleware(store)(next);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;, store.dispatch);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们试一下输出结果：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 先写一个测试 store&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; store = &amp;#123; dispatch: (action) =&amp;gt; &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(action) &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;applyMiddleware(patchLog, patchTimer)(store);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;store.dispatch(&lt;span class=&quot;string&quot;&gt;&#39;hello&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 输出如下：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// begin&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// begin time&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// hello&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// end time&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;吼啊，这个问题就这么解决了，可是很明显第二个坑还是没填上，这个循环调用怎么破解呢？&lt;/p&gt;
&lt;p&gt;这时丹爷又发话了：不用改 &lt;code&gt;store&lt;/code&gt;，我们返回一个&lt;strong&gt;新的&lt;/strong&gt; &lt;code&gt;store&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当你调用的是一个新的 &lt;code&gt;dispatch&lt;/code&gt;，那么在中间件里怎么操作 &lt;code&gt;store.dispatch&lt;/code&gt; 其实都没有关系了。这样一方面保护了原来的 &lt;code&gt;dispatch&lt;/code&gt; 方法不被破坏，同时还提供了上文所说的&lt;strong&gt;阻断功能&lt;/strong&gt;：这时如果在中间件里调用 &lt;code&gt;store.dispatch&lt;/code&gt; 而非 &lt;code&gt;next&lt;/code&gt;，就可以直接阻断中间件的运行。代码实现如下：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;applyMiddleware&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;...middlewares&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (store) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; dispatch = middlewares.reduceRight((next, middleware) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; middleware(store)(next);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;, store.dispatch);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123; ...store, dispatch &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们接着来实现一个异步中间件，并把两个分数改成异步的：&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;jsbin-embed&quot; href=&quot;http://jsbin.com/licabam/embed?js,output&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JS Bin on jsbin.com&lt;/a&gt;&lt;script src=&quot;http://static.jsbin.com/js/embed.min.js?3.35.12&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;额妹子嘤！我们加入了中间件之后，完全没有改动除了 action 和创建 store 以外的任何代码，就完成了各种异步操作，而完全不用在业务里写各种蛋疼的逻辑了。把特殊逻辑交给可插拔式的中间件，而不必改动业务代码，这种是中间件的强大之处。&lt;/p&gt;
&lt;h1 id=&quot;函数式编程的碎碎念&quot;&gt;函数式编程的碎碎念&lt;/h1&gt;&lt;p&gt;看下上面代码，有一个地方还是不太爽，那就是这一行：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.store = applyMiddleware(promiseMiddleware)(createStore(reducer, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.state));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这有点长啊，而且函数套函数，看着都晕了有木有。等等，我们之前似乎解决过这个问题：我们的中间件本身就是函数套函数嘛，可是我们还不是能横着写？这就要扯到函数式编程上来了。&lt;/p&gt;
&lt;p&gt;我们知道《黑客与画家》的作者泡爷就是 lisp 来写他的创业项目 Viaweb 的，甚至这本书一出，掀起了一阵学习 lisp 的装逼小高潮。听说前一阵有 lisp 的爱好者有人打印了一下 Viaweb 的源码，我们把最后一页发出来供大家参考学习：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;        ))))))))))))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      ))))))))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    )))))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;……当然啦，上面的都是开玩笑；不过如果你写过 lisp，一定曾经对着这一堆函数嵌套和括号头疼过。这简直就是阻碍函数式编程普及的恶魔啊！试想一下，要是在 js 里你随便写个什么逻辑都得这样：&lt;code&gt;a(b(c(d(e()))))&lt;/code&gt;，那前端狗们还不得『打得好，我选择屎亡』？&lt;/p&gt;
&lt;p&gt;不过没关系，函数式编程的大哥们早就趟这些坑，他们提出了一个叫做 &lt;code&gt;compose&lt;/code&gt; 的方法，用了这个方法，可以把上面的 &lt;code&gt;a(b(c(d(e(123)))))&lt;/code&gt; 改成：&lt;code&gt;compose(a,b,c,d,e)(123)&lt;/code&gt;。是不是瞬间有了活下去的动力？&lt;/p&gt;
&lt;p&gt;我们来考虑考虑，在 ES6 里，这个函数应该怎么写：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先我们应该把传入的一坨函数改造成数组，这个 ES6 里面的 &lt;a href=&quot;http://es6.ruanyifeng.com/#docs/function#rest参数&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;rest 参数&lt;/a&gt;已经帮我们很好的搞定了；&lt;/li&gt;
&lt;li&gt;其次我们需要&lt;strong&gt;逆序&lt;/strong&gt;执行函数，这一点就用到了上文说过的 &lt;code&gt;reduceRight&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们来实现一下：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;compose&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;...funcs&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; last = funcs.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; rest = funcs;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (...args) =&amp;gt; rest.reduceRight((compose, f) =&amp;gt; f(compose), last(...args));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有了这个利器，我们同时还能改造 &lt;code&gt;applyMiddleware&lt;/code&gt; 里的代码！&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;applyMiddleware&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;...middlewares&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (store) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; dispatch = store.dispatch;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 这里对 store 进行了一次复制&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 防止中间件直接操作 store 本身&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 最大程度防止 store 被中间件破坏&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; miniStore = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            getState: store.getState,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            dispatch: action =&amp;gt; dispatch(action)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; chain = middlewares.map(m =&amp;gt; m(miniStore));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 使用 compose 简化中间件代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dispatch = compose(...chain)(dispatch);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123; ...store, dispatch &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最终我们把代码搞成了这个样子：&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;jsbin-embed&quot; href=&quot;http://jsbin.com/difoza/embed?js,output&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JS Bin on jsbin.com&lt;/a&gt;&lt;script src=&quot;http://static.jsbin.com/js/embed.min.js?3.35.12&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;好啦！扯了这么多，redux 的内容终于说完了。如果你能坚持看到这里，说明朋友你还是对 redux 很感兴趣&lt;del&gt;，或者是觉得我写的太屎准备搜集证据批判我一番的&lt;/del&gt;。不管怎么说，你一定都会有一个很大的疑问：为啥你这儿还有 &lt;code&gt;setState&lt;/code&gt; 啊？这个问题吼啊，这一套的奥秘实际上在 &lt;code&gt;react-redux&lt;/code&gt; 里。也就是说 &lt;code&gt;redux&lt;/code&gt; 本身实际上只是进行了数据流管理的操作，真正和 react 结合的地方还大有文章。&lt;/p&gt;
&lt;h1 id=&quot;与_react_的连接&quot;&gt;与 react 的连接&lt;/h1&gt;&lt;p&gt;其实聪明的读者可能已经看到怎么做了，要想不写 &lt;code&gt;setState&lt;/code&gt;，那直接写 &lt;code&gt;props&lt;/code&gt; 就好了嘛！分分钟改动代码如下（为了演示这个，将例子拆成多个组件的形式）：&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;jsbin-embed&quot; href=&quot;http://jsbin.com/wenile/embed?js,output&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JS Bin on jsbin.com&lt;/a&gt;&lt;script src=&quot;http://static.jsbin.com/js/embed.min.js?3.35.12&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;可是这样的问题就在于，组件中的 store 用的都是唯一的全局变量，我们在进行自动化测试和服务端渲染的时候就比较蛋疼了，毕竟每一次请求服务端渲染，都需要生成一个新的 store 的实例。那我们把最外侧组件的 store 通过 props 传下去呢？比如这样：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;React.render(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Transcript&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;store&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&amp;#123;store&amp;#125;&lt;/span&gt;/&amp;gt;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    document.getElementById(&#39;app&#39;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是 &lt;code&gt;props&lt;/code&gt; 不是子孙传递的，所以要实现这个效果势必只能每个子组件继续往下传递：&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;jsbin-embed&quot; href=&quot;http://jsbin.com/wenile/embed?js,output&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JS Bin on jsbin.com&lt;/a&gt;&lt;script src=&quot;http://static.jsbin.com/js/embed.min.js?3.35.12&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;这太可怕了，除非每写一个 &lt;code&gt;store={ store }&lt;/code&gt; 都能续一秒，不然写这么简直要命。这时机智如你可能已经想到，不是有 &lt;a href=&quot;https://facebook.github.io/react/docs/context.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;context&lt;/a&gt; 嘛！然而事实是，写 context 还要写一堆 &lt;code&gt;contextTypes&lt;/code&gt;，没有比 props 高到哪里去啊，可以参加丹爷的这个&lt;a href=&quot;https://egghead.io/lessons/javascript-redux-passing-the-store-down-with-provider-from-react-redux&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;视频&lt;/a&gt;。但是不要担心，尽管现在还不是很优雅，但是我们最终会把它搞得好看的。&lt;/p&gt;
&lt;h2 id=&quot;Provider&quot;&gt;Provider&lt;/h2&gt;&lt;p&gt;既然我们需要使用 context，我们就必须需要一个 &lt;code&gt;Provider&lt;/code&gt;，这个组件接受一个 store 作为 props，然后把这个 store 放置在 context 中。这个组件还是比较好写的：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &amp;#123;Component, PropTypes&amp;#125; = React;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Provider&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Component&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  constructor(props, context) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(props, context);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.store = props.store;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  getChildContext() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123; store: &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.store &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  render() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 实际的 Provider 这里是 Child.only&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 为了方便起见我们直接使用 div 包裹数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&amp;#123;this.props.children&amp;#125;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 注意，提供 context 的组件需要写 childContextTypes&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Provider.childContextTypes = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  store: PropTypes.object&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;热加载&quot;&gt;热加载&lt;/h2&gt;&lt;p&gt;那我们怎么使子组件更好的接收 context 呢？这个话题我们先放一下，先看看我们之前是怎么让组件更新的——也就是 &lt;code&gt;store.subscribe&lt;/code&gt; 是怎么操作的：我们实际上使用的是 &lt;code&gt;this.forceUpdate()&lt;/code&gt; 这样一个内置 api，使得每一次 &lt;code&gt;dispatch&lt;/code&gt; 的时候强制刷新所有组件。这样无疑效率低下啊……我页面的一个角落更新了，然后整个页面都重载了，虽然咱有 diff-dom，但也不能这么玩儿吧。那传说中 redux 的『热加载』到底是个什么东西呢？&lt;/p&gt;
&lt;p&gt;这时候我们来思考一下，虽然每次 &lt;code&gt;dispatch&lt;/code&gt; 的时候，确实会更新局部的 store，然后其实每个组件依赖的，也只是部分的 store。那如果我们每次更新的时候，发现 store 的某个位置变动了，然后只更新依赖这部分属性的组件不修好了吗！&lt;/p&gt;
&lt;p&gt;那究竟怎么处理呢？我们还是请丹爷来『机械降神』一下：&lt;strong&gt;在每个组件外面都包裹一层&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;是的，我们把这个工作分摊给每个组件，然后在组件的外面包一层：它即处理 context 的部分，也处理 store 组件内部更新逻辑，还处理组件依赖的 store 的部分，一举三得。我们将这个组件称作 &lt;code&gt;connect&lt;/code&gt; 组件，它接受一个参数 &lt;code&gt;mapStateToProps&lt;/code&gt;，将状态树上所属的子状态节点对应到包裹组件的 props 上去。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xinjg.com1.z0.glb.clouddn.com/redux-and-angularjs-redux-arch.jpg&quot; alt=&quot;redux 图示&quot;&gt;&lt;/p&gt;
&lt;p&gt;redux 自诞生之日就被冠以『学习曲线陡峭』之名，让学习者望而却步。然而由于工作需要，最近还是硬着头皮把 redux 的这一套研究了一番，发现传说中陡峭的学习曲线好像也没有那么夸张，我们甚至可以从零开始实现一个基础版本的 redux。&lt;/p&gt;
    
    </summary>
    
      <category term="技术研究" scheme="http://malcolmyu.github.io/malnote/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Javascript" scheme="http://malcolmyu.github.io/malnote/tags/Javascript/"/>
    
      <category term="Redux" scheme="http://malcolmyu.github.io/malnote/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>读《叫魂：1768年中国妖术大恐慌》</title>
    <link href="http://malcolmyu.github.io/malnote/2016/04/02/Reaction-to-Soulstealers/"/>
    <id>http://malcolmyu.github.io/malnote/2016/04/02/Reaction-to-Soulstealers/</id>
    <published>2016-04-01T16:00:00.000Z</published>
    <updated>2016-04-02T12:18:19.000Z</updated>
    
    <content type="html">&lt;p&gt;在弘历的这一任上，大清的盛世梦达到了最高潮。自17世纪开始，玉米、番薯、马铃薯等美洲粮食作物引入中国，战乱的平定和粮食产量的增长使得大清的人口数量翻了一番，从 1.5 亿达到了 3 亿之巨；由于西班牙人在南美的掠夺，导致白银大量流入，尽管带来的一定程度的通货膨胀，却也推动了贸易与土地交易的欣欣向荣。然而在这繁华盛世的背后，独坐龙椅的弘历叔叔却也感到了自己的中年危机。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;弘历的忧虑与民众的狂欢&quot;&gt;弘历的忧虑与民众的狂欢&lt;/h1&gt;&lt;p&gt;由于大清国情的问题，全体社会财富增加的盛世，往往意味着官僚阶层的严重腐败。弘历对于官员们私下捞捞钱的态度，显然比胤禛老爷子要宽容的多；但是腐败带来的问题，却让皇上感到头疼。尽管弘历自己也去江南腐败了好几趟，但他也同时觉得这种奢靡的文化对于满人勤劳勇敢的先进性造成了极大的腐蚀。腐败带来的问题还不仅于此，繁华江南量产的士子们朋比结党，影响朝中的政治风气；地方官僚们在考绩中官官相护，使得整个监督体系形同虚设。简而言之，整个官僚体系已经形成了一个坚实的整体，犹如一架精密有序的机器，即使是拥有绝对权威的君主，也很难干扰它上面任何一个齿轮的运行节奏。&lt;/p&gt;
&lt;p&gt;这使得皇上的意志对于官僚的影响逐级递减，中央对地方不能如臂使指——这才是令弘历最为头疼的一个问题。通常来讲，皇帝对官僚有两个常规的手段来进行一定程度的控制：考绩和监察。然而大清立国已百年，考绩评语日趋拘谨呆板，官员上下级形成一道紧密的关系网，上级对下级的考评除去那些有重大问题的，基本都是好顶赞；监察机构更不用说，基本都是各省的官员在自己监督自己。面对日趋形式化的评定系统，弘历不得不独辟蹊径，采用自己的手段：比如入京陛见，以及在各省安插眼线等。然而在承平日久的大清，这些动作都很难起到太大的影响，整个官僚机器还是那样缓慢有序的运作着，让皇上的手腕显得有些左支右绌。&lt;/p&gt;
&lt;p&gt;然而叫魂案却给了弘历一个契机。这样一场席卷全国的事件，必然有他的主谋——或许幕后有妄图颠覆大清的谋反者也说不定。通过这个『谋反案』，国家进入了&lt;strong&gt;非常规态势&lt;/strong&gt;，皇帝的手里握着一张『政治罪』的王牌，终于可以将专制的手段介入地方，严饬那些已经抱成一团的地方官员。或许在事件的前期，皇上还是发自肺腑的对叫魂事件的影响表示担忧；但是到了事件的后期，见证了一切荒诞与冤屈还依然坚持的皇上，是不是有几分是在贪恋这半年间获得的对官僚系统至高无上的支配权呢？&lt;/p&gt;
&lt;p&gt;反观底层的民众，太平盛世给他们带来的好处，或许没有想象中那样多。尽管粮食产量与社会财富显著上涨，但人口也成倍的增加了，人均资源占有率甚至还有下降的趋势；地区发展不均衡也是一个很大的问题，与苏杭地区的繁华雅致相比，叫魂案发的安徽广德就『僻处万山之中，与徽郡接壤，可耕之田无几，兼以水少潍汇，田皆瘠薄』。人民没有因为商业的快速发展而显得更加优游从容，反而压力更大了。在帝国发展的中后期，社会的上升渠道也逐渐被垄断，『冷籍』&lt;sup&gt;&lt;a href=&quot;#note-1&quot;&gt;注1&lt;/a&gt;&lt;/sup&gt; 在现实中屡受刁难。作者在书里说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在这样一个倍受困扰的社会里，人们会对自己能否通过工作或学习来改善自身的境遇产生怀疑。这种情况由于腐败而不负责任的司法制度而变得更加无法容忍，没有一个平民百姓会指望从这一制度中得到公平的补偿。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于长期缺失权利的底层民众，叫魂案件给他们长期以来被压抑的情绪带来了一个爆发口。相信妖术的人，渴望通过叫魂这种超自然的方式，打击报复自己的对手；不相信妖术的人，也可以利用官府清剿的契机，诬告他人为叫魂犯。这种底层权力幻觉的产生导致的暴乱，在历史上似乎多次存在；然而似乎每一次的类似叫魂的案件，都仅仅是社会无组织力量 &lt;sup&gt;&lt;a href=&quot;#note-2&quot;&gt;注2&lt;/a&gt;&lt;/sup&gt; 扩大化的插曲，最终的结局往往是席卷全国的起义与革命。&lt;/p&gt;
&lt;p&gt;就在弘历叔叔晚年把自己的签名改成『十全老人』之后数年，川楚地区便爆发了旷日持久的白莲教起义，八旗、绿营等中央正规军被彻底打崩，地方团练兴起，中央对地方的控制力日趋下降，弘历叔叔的担心终于变成了现实。好在他已死去，无需亲自来面对这盛世崩塌之后的风雨飘摇。&lt;/p&gt;
&lt;h1 id=&quot;后记&quot;&gt;后记&lt;/h1&gt;&lt;p&gt;不得不说，作为一名学者，孔飞力教授的文笔令人惊叹。书里的前八章对于叫魂事件的描述几乎可以当做小说来看：他将一起夺人眼球的怪力乱神案件——德清石匠案作为入口，展开了长达五章的娓娓道来；他不厌其烦的刻画了下层普通民众的生存状态、中层乡绅官僚的权利博弈、上层乾隆皇帝的内心写照，最终勾勒出一幅十八世纪中叶大天朝的全景图；最后又一口气将这些社会阶层用叫魂案件结合在一起，全书矛盾冲突激烈迸发；然而这震动的大清半壁江山案件却是一场冤案和闹剧，它的结局只能是高潮之后戛然而止，草草收场。在深夜的飞机上一口气全部读完而不觉困顿，足以说明这本书的吸引力。&lt;/p&gt;
&lt;p&gt;尽管像我这样心术不正的读者，读这本书就是为了寻找『现实中历史的影子』 &lt;sup&gt;&lt;a href=&quot;#note-3&quot;&gt;注3&lt;/a&gt;&lt;/sup&gt;，但还是被教授对当时的官僚体系和各阶层任务心理的论述所折服。教授在第三章对弘历同志作为一个满族征服者兼帝国统治者，对剃发问题的微妙心理把握的极为巧妙；对底层民众对僧、乞的态度，以及对叫魂的特殊恐惧也刻画的入木三分。今年 2 月，孔飞力教授与世长辞，愿天国安息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注释&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;b id=&quot;note-1&quot;&gt;注1&lt;/b&gt;：冷籍，指祖辈无科考，却来参加应试的子弟，虽然合法，却会遭受排挤刁难，清末状元张謇就因冷籍而需冒籍考试。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;冷籍者，雖身家淸白，但三代無人與考，其子孫出而應試，則羣詆爲冷籍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;b id=&quot;note-2&quot;&gt;注2&lt;/b&gt;：无组织力量是金观涛夫妇在《兴盛与危机：论中国社会超稳定结构》一书中的提法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;b id=&quot;note-3&quot;&gt;注3&lt;/b&gt;: 本书自出版时，便遇上震动全国的某轮事件，适时书里内容一直被读者拿来与现实做参照，以至于本书的译者都在札记里说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;他所讨论的全是历史，对现实并无半点影射。我们之所以在读此书时会感到似曾相识，那是因为现实中还常常有历史的影子罢了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在弘历的这一任上，大清的盛世梦达到了最高潮。自17世纪开始，玉米、番薯、马铃薯等美洲粮食作物引入中国，战乱的平定和粮食产量的增长使得大清的人口数量翻了一番，从 1.5 亿达到了 3 亿之巨；由于西班牙人在南美的掠夺，导致白银大量流入，尽管带来的一定程度的通货膨胀，却也推动了贸易与土地交易的欣欣向荣。然而在这繁华盛世的背后，独坐龙椅的弘历叔叔却也感到了自己的中年危机。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://malcolmyu.github.io/malnote/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="叫魂" scheme="http://malcolmyu.github.io/malnote/tags/%E5%8F%AB%E9%AD%82/"/>
    
  </entry>
  
  <entry>
    <title>读《人类简史》</title>
    <link href="http://malcolmyu.github.io/malnote/2016/01/12/Reaction-to-A-Brief-History-of-Humankind/"/>
    <id>http://malcolmyu.github.io/malnote/2016/01/12/Reaction-to-A-Brief-History-of-Humankind/</id>
    <published>2016-01-11T16:00:00.000Z</published>
    <updated>2016-02-06T16:50:14.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw1024/620233dbgw1evktg2xeg7j20i20hjmxk.jpg&quot; alt=&quot;『人类，捡屎』&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;自从去年妹子给买了 kindle 之后，前前后后读了很多书，起初的一半读得多是魏晋南北朝的门阀政治，到了后来看了些心理学的，由于一直未做笔记，总觉得没有长进。去年年底去医院挨刀子，穷极无聊之间读了这本《人类简史》，一下子就被书里新奇诡黠的内容吸引了，两天读完电子版，事后还买了纸质版以供仔细阅读。书里记载了许多新奇有趣的观点，我总结了三点，分别对应书里的认知革命、农业革命和科技革命。&lt;/p&gt;
&lt;h1 id=&quot;幻想组织了人类社会&quot;&gt;幻想组织了人类社会&lt;/h1&gt;&lt;p&gt;不错，我们这个社会是由幻想组织的，这才是我们与其他动物之间最根本的区别。对于图腾崇拜和神灵的幻想让原始智人组织了超过150人的大型群落，最终称霸全球；对于社会主义的幻想让我兔领导大众夺取了天下。图腾、神灵和社会主义都是看不见摸不着的东西，却长存人心，这真是一个发人深思的事情。之前看权力的游戏时，蜘蛛和小恶魔的对话令人叫绝：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;蜘蛛：『三位贵人坐在一个房间中：一个国王，一个僧侣和一个富翁。三人之间，站着一名普通佣兵，每位贵人都命佣兵杀死另外二人。孰生，孰死？』&lt;br&gt;小恶魔：那要视那个佣兵而定。&lt;br&gt;蜘蛛：是吗？他既没有王冠，也无金银珠宝，更没有神明的眷顾。&lt;br&gt;小恶魔：但他有利剑，有决定生死的力量。&lt;br&gt;蜘蛛：既然生死取决于士兵，那我们为什么又假装承认国王的权利至高无上呢？奈德·史塔克人头落地，应该负责的究竟是谁？乔佛里？刽子手？还是别的什么东西？&lt;strong&gt;权力存于人心。信则有，不信则无。惑人的把戏，如浮影游墙。即便是矮小之人，也能投射出巨大的影子。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以前看这些对白的时候，并不是很理解权力存于人心的意义；后来看了本书中的观点，感觉似乎确如蜘蛛所说：力量是最初的决定因素，而不是最终的；是个体的，而非群体的。对于个人来说，能发挥的力量终究是有限的；而对于群体来说，能够发挥力量的恰恰是组织术：正是有效的组织使得成千上万人的群落、部队、球场的观众能够井然有序，目标专一。知乎里有一个著名的问答：&lt;a href=&quot;http://zhihu.com/question/20529731/answer/36331627&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;第二次国共内战时期，国民党战败主要是因为军事策略失误吗？&lt;/a&gt; 中督公就在答案里提到，我兔之所以战胜，最根本的原因还是有着强大的组织动员能力。而组织最重要的一点，就是能营造出一种所有人都深信不疑的幻想，或者说是理想。&lt;/p&gt;
&lt;p&gt;那么人类社会的组织结构是怎么产生的呢？&lt;/p&gt;
&lt;h1 id=&quot;对剩余价值的剥削产生了阶级和帝国&quot;&gt;对剩余价值的剥削产生了阶级和帝国&lt;/h1&gt;&lt;p&gt;书里提到，15000年前，全世界的人类开始不约而同的种起了小麦。有了农作物之后，人类的物资开始丰盈，不必过着东奔西走的采摘、捕猎生活，并且开始进行定居。之后人类开始了对于&lt;strong&gt;未来&lt;/strong&gt;的忧虑——在原始的采集社会，人类对于未来是完全没有概念的。对于未来的忧虑使得人类开始进行囤积，最终产生了大量的剩余价值。&lt;/p&gt;
&lt;p&gt;然而不知是幸运还是不幸，物资的丰富并没有使它的制造者们过上更好的日子，反而产生了新的阶层：精英阶层。他们收取赋税，不误农事，从事着政治、军事和艺术的研究。他们的生活日趋优异，而农民们却深陷贫穷。作者在书里说：农业革命实际上是一个骗局，它让更多的人以更糟的状态生活下去。&lt;/p&gt;
&lt;p&gt;久而久之，形成了庞大的帝国，也带来了永世不灭的&lt;strong&gt;阶级&lt;/strong&gt;。多年以来，无数人在消灭阶级的道路上付出了毕生的努力，所有的尝试却依然被历史的车轮碾碎。魏武为了铲除士族，杀孔杀杨，甚至不惜与荀令君闹翻；然而人亡政息，两百年后士族的权利居然大到可以裹挟皇权，寒门子弟即使身居高位，在士族家里竟也无席可坐。尽管在乱世之时，阶级的人员会发生大规模的流动；但一旦国家统一、社会安定，阶级也会逐渐稳固下来。核心成员们依靠血缘组成庞大的堡垒，并制定规则使堡垒合法化；控制着有限的流通渠道，让堡垒外的符合自己要求的人能稍微挤进来。本朝太祖也曾想摧毁这堡垒，然而却酿成了灾难和悲剧，留下累世恶名。&lt;/p&gt;
&lt;p&gt;尽管如此，农业革命还是让大规模的人类得以聚集，依靠&lt;strong&gt;金钱、帝国和宗教&lt;/strong&gt;，构筑起庞大的群落——尽管只有中国这样的神奇民族能够把如果广阔的疆域维持几百年的时间，大部分时间欧亚各国都是一团乱麻。那些盛极一时的大型帝国，如倭马亚王朝、查理曼大帝国，基本都随着创始者的死去而即刻分崩离析。然而在500年前，力量的天平却开始悄悄倾斜：当明武宗正德同志还躲在豹房自嗨的时候，西班牙人科尔特斯仅以千人便征服了墨西哥的阿兹特克帝国；十几年之后，弗朗西斯科·皮萨罗更是仅用200人便灭亡了南美的印加帝国。欧洲的征服者们贪婪的踏上这些陌生的土地，攫取了大量的财富。等到他们强大的军事能力能够快速投放到中国这片古老的土地上时，天朝的子民才发现这惊人的差距。&lt;/p&gt;
&lt;p&gt;那为何胜利的女神选择了欧洲呢？&lt;/p&gt;
&lt;h1 id=&quot;现代科学与资本主义的结合&quot;&gt;现代科学与资本主义的结合&lt;/h1&gt;&lt;p&gt;大概是欧洲的贫瘠与美洲的富足造成了这一切。1484年，哥伦布老师谒见西班牙的伊莎贝拉女王，希望女王能够资助它的舰队绕地球航行发现去东亚的新航线。尽管哥伦布老师最终也没能找到印度在哪儿，但却让西班牙人征服了美洲，获得了无尽的金银矿产、蔗糖和烟草。这一切使得航海家们获得了更多的资助，&lt;del&gt;开启了寻找 One Piece 的大航海时代，&lt;/del&gt;构成了&lt;strong&gt;资本主义信贷&lt;/strong&gt;的奇妙循环：投资带来回报，回报建立信任，信任又转化为更多的信贷；而庞大的中国大陆就没有这么幸运，在科技的曙光到来之前，励精图治的皇帝们已经建立起的官僚阶级已经将触角伸向社会各个角落，大洋和荒漠之外无可发掘，他们只关心税收，对于信贷一无所知。&lt;/p&gt;
&lt;p&gt;信贷的力量，从荷兰的崛起中可窥一斑。在14世纪中叶，小小的荷兰想要挑战庞大的西班牙帝国，可谓是蚍蜉撼树，然而短短的几十年之内，荷兰利用司法独立和保护个人财产的方式，取代了蛮横无理的西班牙王室，获得了欧洲金融体系的信任。随着大量资金的流入，荷兰人不但建立了世界上第一座证券交易所，还取代了西班牙人成为了新一代的海上霸主。它的继任者英国也是走着一样的路子，伦敦证券交易所一支支股票发行，暗示了欧洲金主对这个新兴帝国的赞许与支持。资本主义的力量在欧洲政府世界的过程中展现的淋漓尽致，无怪乎冰火里也要有一个布拉佛斯铁金库的神奇设定。&lt;/p&gt;
&lt;p&gt;帮助欧洲征服者们征服世界的，除了病菌与枪炮，还有&lt;strong&gt;科学&lt;/strong&gt;。英国征服印度之后，动用了数以万计的劳工和学者，对这个文明古国进行了彻头彻尾的大调查，绘制了精密的地图、勘探了各种矿藏资源、挖掘了被遗忘的废墟、发现了印度梵文和语言体系。对于被统治地区的详尽调查，使得统治者们比当地土著还要了解这个大陆；正是知识与科学使得几十万驻印的英国人得以奴役3亿印度人长达两个世纪之久。&lt;/p&gt;
&lt;p&gt;正如相信欧洲之外会有美洲，我们也会相信宇宙深处或是原子核里都蕴含着巨大的能量。因此现在的国家也像当年的伊莎贝拉女王一样，资助着那些研究室里的探索者们继续前行，按照 &lt;strong&gt;投资–&amp;gt;科技进步–&amp;gt;探索征服–&amp;gt;带来丰厚回报–&amp;gt;继续投资&lt;/strong&gt; 的正向循环步步向前。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw1024/620233dbgw1evktg2xeg7j20i20hjmxk.jpg&quot; alt=&quot;『人类，捡屎』&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://malcolmyu.github.io/malnote/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="人类简史" scheme="http://malcolmyu.github.io/malnote/tags/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>协程与事件循环</title>
    <link href="http://malcolmyu.github.io/malnote/2015/11/18/Coroutine-and-Event-Loop/"/>
    <id>http://malcolmyu.github.io/malnote/2015/11/18/Coroutine-and-Event-Loop/</id>
    <published>2015-11-17T16:00:00.000Z</published>
    <updated>2015-11-27T07:32:13.000Z</updated>
    
    <content type="html">&lt;p&gt;最近研究了一下 es6 的生成器函数，以及传说中的 co。虽然网上关于协程、co 源码分析的文章数不胜数，但是将其与先前异步实现的事件队列结合起来说明的文章却很难寻觅。之前只知道协程是实现异步的一种方式，那其和之前的各种异步实现究竟有什么本质区别呢？本文将根据协程机制简要探讨一下&lt;strong&gt;引入协程之后的新的事件循环模型&lt;/strong&gt;。由于笔者基础知识不够扎实，所以会先讲述一大堆协程产生的背景和原理，再进行模型变化的讲解。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;协程实现机制&quot;&gt;协程实现机制&lt;/h1&gt;&lt;h2 id=&quot;进程与线程&quot;&gt;进程与线程&lt;/h2&gt;&lt;p&gt;说起协程就不得不提到面试宝典必备题目之一：啥是进程啥是线程他俩有啥区别？ 之前阮一峰老师写过一篇&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;博文&lt;/a&gt;进行科普，但是文中将电力比作 CPU 以及用厕所比喻锁都不合适。反而是评论里有位叫 viho_he 的哥们说的不错，在这里简单的把他的思路整理一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单核 CPU 无法被平行使用。为了创造『共享』CPU 的假象，搞出了一个叫做时间片的概念，给任务分配时间片进行调度的调度器后来成为操作系统的核心组件；&lt;/li&gt;
&lt;li&gt;在调度的时候，如果不对内存进行管理，那么切换时间片的时候会造成程序上下文的互相污染。但是手工管理物理地址实在是太蛋疼了，因此引入了『虚拟地址』的概念，共包含三个部分：&lt;ul&gt;
&lt;li&gt;CPU 增加了内存管理单元模块，来进行虚拟地址和物理地址的转换；&lt;/li&gt;
&lt;li&gt;操作系统加入了内存管理模块，负责管理物理内存和虚拟内存；&lt;/li&gt;
&lt;li&gt;发明了一个概念叫做&lt;strong&gt;进程&lt;/strong&gt;。进程的虚拟地址一样，经过操作系统和 MMU 映射到不同的物理地址上。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;深入的谈一谈进程。进程是由一大堆元素组成的一个实体，其中最基本的两个元素就是&lt;strong&gt;代码&lt;/strong&gt;和能够被代码控制的&lt;strong&gt;资源&lt;/strong&gt;（包括内存、I/O、文件等）；一个进程从产生到消亡，可以被操作系统&lt;strong&gt;调度&lt;/strong&gt;。掌控资源和能够被调度是进程的两大基本特点。但是进程作为一个基本的调度单位有点不人性：假如我想一边循环输出 hello world，一边接收用户输入计算加减法，就得起俩进程，那随便写个代码都像 chrome 一样变成内存杀手了。&lt;/li&gt;
&lt;li&gt;因此诞生了&lt;strong&gt;线程&lt;/strong&gt;的概念，线程在进程内部，处理并发的逻辑，拥有&lt;strong&gt;独立的栈&lt;/strong&gt;，却共享线程的资源。使用线程作为 CPU 的基本调度单位显得更加有效率，但也引发各种抢占资源的问题&lt;del&gt;，使得笔试又多了一个考题&lt;/del&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后总结一下就是：进程掌握着独立资源，线程享受着基本调度。一个进程里跑多个线程处理并发，6 的飞起。但纯粹的内核态线程有一个问题就是性能消耗：线程切换的时候，进程需要为了管理而切换到内核态，状态转换的消耗有点严重。为此又产生了一个概念，唤做&lt;strong&gt;用户态线程&lt;/strong&gt;。用户态线程吼啊，程序自己控制状态切换，进程不用陷入内核态，会玩儿的开发者可以按照程序的特性来选择更适合的调度算法，代码的效率飞了起来。&lt;/p&gt;
&lt;h2 id=&quot;协程、子例程与生成器&quot;&gt;协程、子例程与生成器&lt;/h2&gt;&lt;p&gt;那协程是干啥的咧？实际上，协程的概念产生的非常早，&lt;a href=&quot;https://en.wikipedia.org/wiki/Melvin_Conway&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Melvin Conway&lt;/a&gt; 早在 1963 年就针对编辑器的设计提出一种将『语法分析』和『词法分析』分离的方案，把 token 作为货物，将其转换为经典的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;『生产者-消费者问题』&lt;/a&gt;。编译器的控制流在词法和语法解析之间来回切换：当词法模块读入足够多的 token 时，控制流交给语法分析；当语法分析消化完所有 token 后，控制流交给词法分析。从这一概念提出的环境我们可以看出，协程的核心思想在于：&lt;strong&gt;控制流的主动让出和恢复&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这一点和上文说的用户态线程有几分相似，但是用户态线程多在语言层面实现，对于使用者还是不够开放，无法提供显示的调度方式。但是协程做到了这一点，用户可以在编码阶段通过类似 &lt;code&gt;yieldto&lt;/code&gt; 原语对控制流进行调度。&lt;/p&gt;
&lt;p&gt;说到这里可能有读者会产生疑问：『我大协程这么吊，为何提出了这么多年一直不火啊？』这就要说到当年命令式编程与函数式编程的『剑气之争』，当年命令式编程围绕着自顶向下的开发理念，将子例程调用作为唯一的控制结构。实际上，子例程就是没用使用 &lt;code&gt;yield&lt;/code&gt; 的协程，大宗师 &lt;a href=&quot;https://en.wikipedia.org/wiki/Donald_Knuth&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Donald E. Knuth&lt;/a&gt; 也曾经曰过：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;子例程是协程的一种特例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但不进行让步和恢复的协程，终究失掉了协程的灵魂内核，不能称之为协程。直到后来出现了一个叫做&lt;strong&gt;迭代器（Iterator）&lt;/strong&gt;的神奇的东西。迭代器的出现主要还是因为数据结构日趋复杂，以前用 &lt;code&gt;for&lt;/code&gt; 循环就可以遍历的结构需要抽象出一个独立的迭代器来支持遍历，用 js 为例。迭代器的遍历会搞成下面这个样子：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; key &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.keys(obj)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(key + &lt;span class=&quot;string&quot;&gt;&quot;: &quot;&lt;/span&gt; + obj[key]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实际上，要实现这种迭代器的语法糖，就必须引入协程的思想：主执行栈在进入循环后先让步给迭代器，迭代器取出下一个迭代元素之后再恢复主执行栈的控制流。这种迭代器的实现就是因为内置了&lt;del&gt;葛炮&lt;/del&gt;&lt;strong&gt;生成器（generator）&lt;/strong&gt;。生成器也是一种特殊的协程，它拥有 &lt;code&gt;yield&lt;/code&gt; 原语，但是却不能指定让步的协程，&lt;strong&gt;只能让步给生成器的调用者或恢复者&lt;/strong&gt;。由于不能多个协程跳来跳去，生成器相对主执行线程来说只是一个可暂停的玩具，它甚至都&lt;strong&gt;不需要&lt;/strong&gt;另开新的执行栈，只需要在让步的时候保存一下上下文就好。因此我们认为生成器与主控制流的关系是不对等的，也称之为&lt;strong&gt;非对称协程（semi-coroutine）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;由此我们也知道了，为啥 es6 一下引起了这么一大坨特性啊，因为引入迭代器，就必须引入生成器，这俩就是这种不可分割的基友关系。&lt;/p&gt;
&lt;h1 id=&quot;现有协程的实现&quot;&gt;现有协程的实现&lt;/h1&gt;&lt;p&gt;自 es6 尝试引入生成器以来，大量的协程实现尝试开始兴起，协程一时间成为风靡前端界的新名词。但这些实现中有的仅仅是实现了一个看上去很像协程的语法糖，有的却 hack 了底层代码，实现了真正的协程。这里以 TJ 大神的 &lt;a href=&quot;https://github.com/tj/co&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;co&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/laverdet/node-fibers&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;node-fibers&lt;/a&gt; 为例，浅析这两种协程实现方式上的差异。&lt;/p&gt;
&lt;h2 id=&quot;CO&quot;&gt;CO&lt;/h2&gt;&lt;p&gt;co 实际上是一个语法糖，它可以包裹一个生成器，然后生成器里可以使用同步的方式来编写异步代码，效果如下：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; fs = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;fs&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; readFile = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;fileName&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;resolve, reject&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fs.readFile(fileName, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;error, data&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (error) reject(error);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            resolve(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;co(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;* (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; f1 = &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; readFile(&lt;span class=&quot;string&quot;&gt;&#39;/etc/fstab&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; f2 = &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; readFile(&lt;span class=&quot;string&quot;&gt;&#39;/etc/shells&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; sum = f1.toString().length + f2.toString().length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(sum);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 es7 中已经推出了一个更甜的语法糖： &lt;code&gt;async/await&lt;/code&gt;，实现效果如下：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; f1 = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; readFile(&lt;span class=&quot;string&quot;&gt;&#39;/etc/fstab&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; f2 = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; readFile(&lt;span class=&quot;string&quot;&gt;&#39;/etc/shells&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; sum = f1.toString().length + f2.toString().length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(sum);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;是不是碉堡了！这段代码仿佛是在说明：我们把 &lt;code&gt;readFile&lt;/code&gt; 丢到另一个协程里去了！等他搞定之后就又回到主线程上！代码可读性 6666 啊！但事实真的是这样的么？我们来看一下 co 的不考虑异常处理的精简版本实现：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;co&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;gen&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; def = &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;.defer();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; iter = gen();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;resolve&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;data&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 恢复迭代器并带入promise的终值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        step(iter.next(data));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;step&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;it&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        it.done ?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 迭代结束则解决co返回的promise&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            def.resolve(it.value) :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 否则继续用解决程序解决下一个让步出来的promise&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            it.value.then(resolve);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    resolve();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; def.promise;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从 co 的代码实现可以看出，实际上 co 只是进行了对生成器让步、恢复的控制，把让步出来的 promise 对象求取终值，之后恢复给生成器——这都没有多个执行栈，并没有什么协程么！但是有观众会指出：这不是用了生成器么，生成器就是非对称协程，所以它就是协程！好的，我们再来捋一捋：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;协程在诞生之时，只有一个 Ghost，叫做&lt;strong&gt;主动让步和恢复控制流&lt;/strong&gt;，协程因之而生；&lt;/li&gt;
&lt;li&gt;后来在实现上，发现可以采用可控用户态线程的方式来实现，因此这种线程成为了协程的一个 shell。&lt;/li&gt;
&lt;li&gt;后来又发现，生成器也可以实现一部分主动让步和恢复的功能，但是弱了一点，我们也称生成器为协程的一个弱弱的 shell。&lt;/li&gt;
&lt;li&gt;所以我们说起协程，实际上说的是它的 Ghost，只要能主动让步和恢复，就可以叫做协程；但协程的实现方式有多种，有的有独立栈，有的没有独立栈，他们都只是协程的壳，不要在意这些细节，嗯。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;好的，因此 TJ 大神叫它 co，也还是有一定道理的，尽管可能产生一些奇怪的误导……我们来看一下，引入了 co 之后，js 原有的事件循环产生了什么改变呢？&lt;/p&gt;
&lt;p&gt;【回头补个图】&lt;/p&gt;
&lt;p&gt;好吧，实际上并没有什么改变。因为 promise 本身的实现机制还是回调，所以在 &lt;code&gt;then&lt;/code&gt; 的时候就把回调扔给 webAPI 了，等到合适的时机又扔回给事件队列。事件队列中的代码需要等到主栈清空的时候再运行，这时候执行了 &lt;code&gt;iter.next&lt;/code&gt; 来恢复生成器——而生成器是没有独立栈的，只有一份保存的上下文；因此只是把生产器的上下文再次加载到栈顶，然后沿着恢复的点继续执行而已。引入生成器之后，事件循环的一切都木有改变！&lt;/p&gt;
&lt;h2 id=&quot;Node-fibers&quot;&gt;Node-fibers&lt;/h2&gt;&lt;p&gt;看完了生成器的实现，我们再来看下真·协程的效果。这里以 hack 了 node.js 线程的 &lt;code&gt;node-fibers&lt;/code&gt; 为例，看一下真·协程与生产器的区别在何处。&lt;/p&gt;
&lt;p&gt;首先，&lt;code&gt;node-fibers&lt;/code&gt; 本身仅仅是实现了创造协程的功能以及一些原语，本身并没有类似 co 的异步转同步的语法糖，我们采用相似的方式来包裹一个，为了区别，就叫它 ceo 吧（什么鬼）：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; Fiber = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;fibers&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ceo&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;cb&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; def = &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;.defer();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 注意这里传入的是回调函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; fiber = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Fiber(cb);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;resolve&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;data&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 恢复迭代器并带入promise的终值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        step(fiber.run(data));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;step&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;it&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        !fiber.started ?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 迭代结束则解决co返回的promise&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            def.resolve(it.value) :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 否则继续用解决程序解决下一个让步出来的promise&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            it.then(resolve);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    resolve();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; def.promise;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ceo(() =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; f1 = Fiber.yield(readFile(&lt;span class=&quot;string&quot;&gt;&#39;/etc/fstab&#39;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; f2 = Fiber.yield(readFile(&lt;span class=&quot;string&quot;&gt;&#39;/etc/shells&#39;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; sum = f1.toString().length + f2.toString().length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(sum);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;观众老爷会说了，这不是差不多么！好像最大的区别就是生成器变成了回调函数，只是少了一个 &lt;code&gt;*&lt;/code&gt; 嘛。错！这就是区别！这里最关键的一点在于：没有了生成器，我们可以在任意一层函数里进行让步，这里使用 &lt;code&gt;ceo&lt;/code&gt; 包裹的这个回调，是一个真正&lt;strong&gt;独立的执行栈&lt;/strong&gt;。在真·协程里，我们可以搞出这样的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ceo(() =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; foo1 = a =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;read from file1&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; ret = Fiber.yield(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ret;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; foo2 = b =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;read from file2&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; ret = Fiber.yield(b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ret;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; getSum = () =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; f1 = foo1(readFile(&lt;span class=&quot;string&quot;&gt;&#39;/etc/fstab&#39;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; f2 = foo2(readFile(&lt;span class=&quot;string&quot;&gt;&#39;/etc/shells&#39;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; f1.toString().length + f2.toString().length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; sum = getSum();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(sum);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过这个代码可以发现，在第一次让步被恢复的时候，恢复的是一坨执行栈！从栈顶到栈底依次为：&lt;code&gt;foo1&lt;/code&gt; =&amp;gt; &lt;code&gt;getSum&lt;/code&gt; =&amp;gt; &lt;code&gt;ceo&lt;/code&gt; 里的匿名函数；而使用生成器，我们就无法写出这样的程序，因为 &lt;code&gt;yield&lt;/code&gt; 原语只能在生产器内部使用——无论什么时候被恢复，都是简单的恢复在生成器内部，所以说生成器是不用开新栈滴。&lt;/p&gt;
&lt;p&gt;那么问题就来了，使用了真·协程之后，原先的事件循环模型是否会发生改变呢？是不是主执行栈调用协程的时候，协程就会在自己的栈里跑，而主栈就排空了可以执行异步代码呢？我们来看下面这个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;pi&quot;&gt;&quot;use strict&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; Fiber = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;fibers&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; syncTask = () =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; now = +&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt; - now &amp;lt; &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;) &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;SyncTask Loaded!&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; asyncTask = () =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setTimeout(() =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;AsyncTask Loaded!&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; fiber = Fiber(() =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    syncTask();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Fiber.yield();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;mainThread&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    asyncTask();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fiber.run();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mainThread();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 输出：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// SyncTask Loaded!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// AsyncTask Loaded!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们在主线程执行的时候抛出了一个异步方法，之后在协程里用冗长的同步代码阻塞它，这里我们可以清楚的看到：阻塞任何一个执行中的协程都会阻塞掉主线程！也就是说，即使加入了协程，js 还是可以被认为是单线程的，因为&lt;strong&gt;同一时刻势必只有一个协程在运行&lt;/strong&gt;，在协程运行和恢复期间，js 会将当前栈保存，然后用对应协程的栈来填充主的执行栈。&lt;strong&gt;只有所有协程都被挂起或运行结束，才能继续运行异步代码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因此，真·协程的引入对事件循环还是造成了一定的影响，可怜的异步代码要等的更久了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近研究了一下 es6 的生成器函数，以及传说中的 co。虽然网上关于协程、co 源码分析的文章数不胜数，但是将其与先前异步实现的事件队列结合起来说明的文章却很难寻觅。之前只知道协程是实现异步的一种方式，那其和之前的各种异步实现究竟有什么本质区别呢？本文将根据协程机制简要探讨一下&lt;strong&gt;引入协程之后的新的事件循环模型&lt;/strong&gt;。由于笔者基础知识不够扎实，所以会先讲述一大堆协程产生的背景和原理，再进行模型变化的讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="技术研究" scheme="http://malcolmyu.github.io/malnote/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="event loop" scheme="http://malcolmyu.github.io/malnote/tags/event-loop/"/>
    
      <category term="yield" scheme="http://malcolmyu.github.io/malnote/tags/yield/"/>
    
      <category term="协程" scheme="http://malcolmyu.github.io/malnote/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Git 钩子</title>
    <link href="http://malcolmyu.github.io/malnote/2015/10/16/Git-Hooks/"/>
    <id>http://malcolmyu.github.io/malnote/2015/10/16/Git-Hooks/</id>
    <published>2015-10-15T16:00:00.000Z</published>
    <updated>2015-11-27T07:32:04.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xinjg.com1.z0.glb.clouddn.com/git-tips-hookhero.svg&quot; alt=&quot;Git 钩子&quot;&gt;&lt;/p&gt;
&lt;p&gt;Git 钩子是在一个 Git 仓库中，在每一次特定事件触发时自动运行的脚本。它允许我们自定义 Git 的内部行为，并在开发的生命周期的关键时间点触发自定义行为。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;image src=&quot;http://7xinjg.com1.z0.glb.clouddn.com/git-tips-hook01.svg&quot; alt=&quot;通过链接到版本控制的脚本维护钩子&quot; width=&quot;80%&quot;&gt;&lt;/image&gt;&lt;/p&gt;

&lt;p&gt;Git 钩子通常的使用案例包含支持一个提交策略，根据仓库状态替换项目环境，以及实现连续集成的工作流。但由于脚本是可以任意指定的，所以我们几乎可以使用 Git 的钩子来自动化或优化我们开发工作流的方方面面。&lt;/p&gt;
&lt;p&gt;本文的一开始我们先从概念上概述一下 Git 钩子是怎么工作的；之后我们会研究一些使用在本地和服务端仓库的最流行的钩子的使用。&lt;/p&gt;
&lt;h1 id=&quot;概念概述&quot;&gt;概念概述&lt;/h1&gt;&lt;p&gt;所有的 Git 钩子都是普通的脚本，只是在仓库的特定时机会被 Git 执行。这是得钩子们的安装和配置十分容易。&lt;/p&gt;
&lt;p&gt;钩子可以放置在本地或服务端的仓库中，它们仅对各自的仓库行为做出相应并执行。我们会在下文中具体看一下钩子的类型。应用在本地和服务端的钩子的配置会在余下的章节中进行讨论。&lt;/p&gt;
&lt;h2 id=&quot;安装钩子&quot;&gt;安装钩子&lt;/h2&gt;&lt;p&gt;钩子存放在每个 Git 仓库的 &lt;code&gt;.git/hooks&lt;/code&gt; 目录。当我们初始化仓库时，Git 会自动生成此目录并在里面放置一些示例脚本。如果你去看一眼 &lt;code&gt;.git/hooks&lt;/code&gt; 目录的内容，就会看到如下的文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;applypatch-msg&lt;span class=&quot;class&quot;&gt;.sample&lt;/span&gt;       pre-push&lt;span class=&quot;class&quot;&gt;.sample&lt;/span&gt;
commit-msg&lt;span class=&quot;class&quot;&gt;.sample&lt;/span&gt;           pre-rebase&lt;span class=&quot;class&quot;&gt;.sample&lt;/span&gt;
post-update&lt;span class=&quot;class&quot;&gt;.sample&lt;/span&gt;          prepare-commit-msg&lt;span class=&quot;class&quot;&gt;.sample&lt;/span&gt;
pre-applypatch&lt;span class=&quot;class&quot;&gt;.sample&lt;/span&gt;       update&lt;span class=&quot;class&quot;&gt;.sample&lt;/span&gt;
pre-commit.sample
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里提供了许多可用的钩子，但是 &lt;code&gt;.simple&lt;/code&gt; 的后缀使它们都不能默认执行。想要『安装』某一个钩子，我们所需要做的仅仅是移除 &lt;code&gt;.simple&lt;/code&gt; 的扩展名。或者如果你动手撸了一个新脚本，那你可以将脚本添加到路径里，并用上面的文件名来命名你的脚本，记得去掉 &lt;code&gt;.simple&lt;/code&gt; 后缀哟。&lt;/p&gt;
&lt;p&gt;我们安装一个简单的 &lt;code&gt;prepare-commit-msg&lt;/code&gt; 钩子作为示例。删除文件的 &lt;code&gt;.simple&lt;/code&gt; 后缀，并将下面的内容添加到文件中：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;shebang&quot;&gt;#!/bin/sh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;# 请输入一条有用的提交信息！&quot;&lt;/span&gt; &amp;gt; &lt;span class=&quot;variable&quot;&gt;$1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;钩子文件必须可执行，因此如果我们是徒手撸的脚本，我们需要更改文件的权限。例如，如果想要使 &lt;code&gt;prepare-commit-msg&lt;/code&gt; 文件可执行，就需要运行下面的命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chmod +x &lt;span class=&quot;operator&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;prepare&lt;/span&gt;-&lt;span class=&quot;keyword&quot;&gt;commit&lt;/span&gt;-msg&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在我们应该能在每次运行 &lt;code&gt;git commit&lt;/code&gt; 的时候看到默认的提交信息（就是上文脚本里的『请输入一条有用的提交信息』）。我们将在 &lt;strong&gt;准备提交信息&lt;/strong&gt; 一章仔细研究其工作机制；而现在我们只需要臭美一下：我们已经能自定义 Git 内部的方法啦！&lt;/p&gt;
&lt;p&gt;内置的样例脚本是非常有用的参考，它们展示了传递给每个钩子的参数详情（这些参数在钩子之间顺序传递）。&lt;/p&gt;
&lt;h2 id=&quot;脚本语言&quot;&gt;脚本语言&lt;/h2&gt;&lt;p&gt;内置的脚本多是 shell 或 perl 脚本，但是只要我们编写的脚本能够执行，就可以使用任何喜欢的脚本语言。每个脚本文件的 &lt;strong&gt;事务行（shebang line）&lt;/strong&gt; 定义了该文件的解释方式。因此想要使用其他的脚本语言，我们只需要改变事务行中解释器的路径就可以了。&lt;/p&gt;
&lt;p&gt;举例来说，我们可以在 &lt;code&gt;prepare-commit-msg&lt;/code&gt; 文件中编写一个可执行的 Python 脚本来替代 shell 脚本。下面的钩子和上一节的 shell 脚本的执行效果完全一致。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#!/usr/bin/env python&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; sys, os&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;commit_msg_filepath = sys.argv[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; open(commit_msg_filepath, &lt;span class=&quot;string&quot;&gt;&#39;w&#39;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; f:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    f.write(&lt;span class=&quot;string&quot;&gt;&quot;# Please include a useful commit message!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;留心一下文件的第一行指到了 Python 的解释器；同时，我们使用 &lt;code&gt;sys.argv[1]&lt;/code&gt; 来代替 &lt;code&gt;$1&lt;/code&gt; 来指代传入脚本的第一个参数（我们会在稍后对此进行详述）。&lt;/p&gt;
&lt;p&gt;这是 Git 钩子的一个非常给力的特性，使得我们可以使用我们喜欢用的的任何脚本语言来编程。&lt;/p&gt;
&lt;h2 id=&quot;钩子的作用域&quot;&gt;钩子的作用域&lt;/h2&gt;&lt;p&gt;钩子在存在于每一个 Git 仓库，且当我们运行 &lt;code&gt;git clone&lt;/code&gt; 时它们 &lt;strong&gt;不会&lt;/strong&gt; 被复制到新仓库中。而且由于钩子是本地的，它们就可以被任何有仓库访问权限的人修改。&lt;/p&gt;
&lt;p&gt;这对于一个团队的开发者进行钩子的配置有着重要影响。首先，我们需要找到一种方式来确保钩子在我们的团队成员之间实时更新；其次，我们不能强迫开发者来都用特定的方式来提交，顶多只能鼓励大家这么做。&lt;/p&gt;
&lt;p&gt;维护一个开发团队的钩子可是有点棘手，因为 &lt;code&gt;.git/hooks&lt;/code&gt; 目录不会随着项目的其他部分复制的，也不会被版本控制。对上面俩问题的最简单的解决方案就是把钩子存在实际的项目目录中（&lt;code&gt;.git&lt;/code&gt; 目录之外），这就可以让我们像任何其他版本控制文件一样来编辑钩子。为了安装钩子，我们可以创造一个链接将其链接到 &lt;code&gt;.git/hooks&lt;/code&gt;；或者是当有更新的时候，简单的将其复制粘贴到 &lt;code&gt;.git/hooks&lt;/code&gt; 目录中。&lt;/p&gt;
&lt;p&gt;&lt;image src=&quot;http://7xinjg.com1.z0.glb.clouddn.com/git-tips-hook02.svg&quot; alt=&quot;在提交创建的过程执行钩子&quot; width=&quot;80%&quot;&gt;&lt;/image&gt;&lt;/p&gt;

&lt;p&gt;另外，Git 还提供一个&lt;a href=&quot;http://git-scm.com/docs/git-init#_template_directory&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;模板目录&lt;/a&gt;的机制来更加便捷的自动安装钩子。模板目录的所有文件和目录在每次使用 &lt;code&gt;git init&lt;/code&gt; 和 &lt;code&gt;git clone&lt;/code&gt; 时都会被复制进 &lt;code&gt;.git&lt;/code&gt; 目录里。&lt;/p&gt;
&lt;p&gt;下文所述的所有本地钩子都可以被仓库管理员替换或删除，这完全取决于每个团队成员是否实际使用钩子。我们最好记住这一点，把 Git 钩子当做一个方便的开发者工具而非一个严格执行的开发政策。&lt;/p&gt;
&lt;p&gt;即便如此，我们也可以用服务端钩子来拒绝那些不符合标准的提交。我们会在稍后讨论这一点。&lt;/p&gt;
&lt;h1 id=&quot;本地钩子&quot;&gt;本地钩子&lt;/h1&gt;&lt;p&gt;本地钩子只影响它们所在的仓库。当我们读到这一节时，要记住每位开发者都可以替换其本地的钩子，我们不能使用钩子作为一种强制提交策略。然钩子却使得开发人员更容易坚持既定的开发方针。&lt;/p&gt;
&lt;p&gt;在这一节里，我们将展示6个最常用的本地钩子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pre-commit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prepare-commit-msg&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;commit-msg&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;post-commit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;post-checkout&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pre-rebase&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前四个钩子允许我们在整个提交的生命周期中插入，后面两个允许我们分别为 &lt;code&gt;git checkout&lt;/code&gt; 和 &lt;code&gt;git rebase&lt;/code&gt; 执行一些额外的行为或者安全检查。&lt;/p&gt;
&lt;p&gt;所有的以 &lt;code&gt;pre-&lt;/code&gt; 为前缀的钩子都允许我们在后缀的行为 &lt;strong&gt;即将发生&lt;/strong&gt; 的时候改变这些行为；而以 &lt;code&gt;post-&lt;/code&gt; 为前缀的钩子 &lt;strong&gt;仅用于通知&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们也会看到一些实用的技术来解析钩子参数，以及实用底层 Git 命令请求仓库信息。&lt;/p&gt;
&lt;h2 id=&quot;预提交钩子_Pre-Commit&quot;&gt;预提交钩子 Pre-Commit&lt;/h2&gt;&lt;p&gt;&lt;code&gt;pre-commit&lt;/code&gt; 的脚本在每次运行 &lt;code&gt;git commit&lt;/code&gt; 命令时，在 Git 要求开发者填写提交信息和生成提交对象之前执行。我们可以用这个钩子在快照将要被提交的时刻对其进行检查。比方说，我们也许想要在此时运行一些自动测试，以防止本次提交破坏现有功能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pre-commit&lt;/code&gt; 脚本没有传入参数，并且以非零状态退出&lt;sup&gt;&lt;a href=&quot;#note-1&quot;&gt;注1&lt;/a&gt;&lt;/sup&gt;会终止整个提交。让我们看一下一个简化的内置 &lt;code&gt;pre-commit&lt;/code&gt; 钩子。这个脚本在发现有空白符的错误时会终止整个提交，空白符错误在 &lt;code&gt;git diff-index&lt;/code&gt; 命令的 &lt;code&gt;--check&lt;/code&gt; 参数里有详细定义（行尾空白符、仅有空白符的行、行首缩进的 tab 后面有空格等格式在默认情况下都会被认为是错误的）。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;shebang&quot;&gt;#!/bin/sh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 检测是否为初始提交&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; git rev-parse --verify HEAD &amp;gt;/dev/null &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;gt;&amp;amp;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;pre-commit: About to create a new commit...&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    against=HEAD&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;pre-commit: About to create the first commit...&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    against=&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;b825dc642cb6eb9a060e54bf8d69288fbee4904&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fi&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 使用 git diff-index 来检测空白符错误&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;pre-commit: Testing for whitespace errors...&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ! git diff-index --check --cached &lt;span class=&quot;variable&quot;&gt;$against&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;pre-commit: Aborting commit due to whitespace errors&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;pre-commit: No whitespace errors :)&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fi&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了使用 &lt;code&gt;git diff-index&lt;/code&gt;，我们需要指出需要用来做比较的提交引用。这个引用通常来说是 &lt;code&gt;HEAD&lt;/code&gt;，但是在初始提交的时候不存在 &lt;code&gt;HEAD&lt;/code&gt; 指针，因此我们的第一个任务就是处理这个边界值。我们使用 &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-rev-parse.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;git rev-parse --verify&lt;/code&gt;&lt;/a&gt; 命令，该命令可以检查参数是否是一个可用引用。&lt;code&gt;&amp;gt;/dev/null 2&amp;gt;&amp;amp;1&lt;/code&gt; 的部分表示不显示所有 &lt;code&gt;git rev-parse&lt;/code&gt; 命令的输出。将 HEAD 或是初始提交的空提交对象存放在 &lt;code&gt;against&lt;/code&gt; 变量中来给 &lt;code&gt;git diff-index&lt;/code&gt; 使用，而 &lt;code&gt;4b825d...&lt;/code&gt; 这个哈希值是一个魔术提交 ID，表示一个空提交。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git diff-index --cached&lt;/code&gt; 命令将当前暂存区与一个提交进行对比，传入 &lt;code&gt;--check&lt;/code&gt; 选项表示我们要求在改动包含空白符错误时给出警告。如果存在空白符错误，我们终止提交并返回退出状态 &lt;code&gt;1&lt;/code&gt;，否则我们以 &lt;code&gt;0&lt;/code&gt; 退出，且提交工作流正常工作。&lt;/p&gt;
&lt;p&gt;这仅仅是 &lt;code&gt;pre-commit&lt;/code&gt; 钩子的一个简单例子：使用 Git 命令来在由请求提交引入的更改上运行测试。我们同样可以在 &lt;code&gt;pre-commit&lt;/code&gt; 钩子中通过执行其他脚本来做任何想做的事情，例如运行一个第三方测试组件，或者使用 Lint 来检查代码格式。&lt;/p&gt;
&lt;h2 id=&quot;准备提交信息钩子_Prepare_Commit_Message&quot;&gt;准备提交信息钩子 Prepare Commit Message&lt;/h2&gt;&lt;p&gt;&lt;code&gt;prepare-commit-msg&lt;/code&gt; 钩子在 &lt;code&gt;pre-commit&lt;/code&gt; 钩子之后调用，用于给提交的文本编辑器填充提交信息。这是一个替换压缩提交和合并提交时自动生成提交信息的一个好时机。&lt;/p&gt;
&lt;p&gt;有 1 到 3 个参数会被传递给 &lt;code&gt;prepare-commit-msg&lt;/code&gt; 脚本：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;包含提交信息的临时文件名。我们通过替换这个文件来更改提交信息。&lt;/li&gt;
&lt;li&gt;提交的类型。包含 &lt;code&gt;message&lt;/code&gt; （带有 &lt;code&gt;-m&lt;/code&gt; 或 &lt;code&gt;-F&lt;/code&gt;）、template （带有 &lt;code&gt;-t&lt;/code&gt;）、&lt;code&gt;merge&lt;/code&gt;（如果提交是一个合并提交）或者 &lt;code&gt;squash&lt;/code&gt; （如果提交是从其他提交中合并的）。&lt;/li&gt;
&lt;li&gt;相关提交的 SHA1 哈希值。只有带有 &lt;code&gt;-c&lt;/code&gt;、&lt;code&gt;-C&lt;/code&gt; 或 &lt;code&gt;--amend&lt;/code&gt; 的提交会给出这个参数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;和 &lt;code&gt;pre-commit&lt;/code&gt; 一样，如果脚本以非零状态退出会中止提交。&lt;/p&gt;
&lt;p&gt;在上一节我们已经看到了一个简单的编辑提交信息的例子，但是还是让我们看一下一个更加有用的脚本。当使用 issue 来跟踪问题时，惯例是在一个单独的分支里解决一个对应的问题。如果我们在分支名称上包含了 issue 号，我们就可以编写一个 &lt;code&gt;prepare-commit-msg&lt;/code&gt; 脚本来在这一分支的每一个提交上都自动导入 issue 号。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#!/usr/bin/env python&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; sys, os, re&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; subprocess &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; check_output&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 收集参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;commit_msg_filepath = sys.argv[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; len(sys.argv) &amp;gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    commit_type = sys.argv[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    commit_type = &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; len(sys.argv) &amp;gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    commit_hash = sys.argv[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    commit_hash = &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;prepare-commit-msg: File: %s\nType: %s\nHash: %s&quot;&lt;/span&gt; % (commit_msg_filepath, commit_type, commit_hash)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 找出当前所在分支&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;branch = check_output([&lt;span class=&quot;string&quot;&gt;&#39;git&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;symbolic-ref&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;--short&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;HEAD&#39;&lt;/span&gt;]).strip()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;prepare-commit-msg: On branch &#39;%s&#39;&quot;&lt;/span&gt; % branch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 如果存在 issue 号，则生成带有 issue # 的提交信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; branch.startswith(&lt;span class=&quot;string&quot;&gt;&#39;issue-&#39;&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;prepare-commit-msg: Oh hey, it&#39;s an issue branch.&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    result = re.match(&lt;span class=&quot;string&quot;&gt;&#39;issue-(.*)&#39;&lt;/span&gt;, branch)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    issue_number = result.group(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; open(commit_msg_filepath, &lt;span class=&quot;string&quot;&gt;&#39;r+&#39;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; f:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        content = f.read()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        f.seek(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        f.write(&lt;span class=&quot;string&quot;&gt;&quot;ISSUE-%s %s&quot;&lt;/span&gt; % (issue_number, content))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;首先，上面的 &lt;code&gt;prepare-commit-msg&lt;/code&gt; 钩子展示了我们怎么获取传入脚本的所有参数。之后，它调用了 &lt;code&gt;git symbolic-ref --short HEAD&lt;/code&gt; 来获取当前分支。如果分支名字以 &lt;code&gt;issue-&lt;/code&gt; 开头，脚本就会重写提交信息文件的内容，在开头的一行引入 issue 号。因此，如果你的分支名是 &lt;code&gt;issue-224&lt;/code&gt;，运行脚本就会生成下列提交信息：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ISSUE-&lt;span class=&quot;number&quot;&gt;224&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Please enter the commit message for your changes. Lines starting &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# with &#39;#&#39; will be ignored, and an empty message aborts the commit. &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# On branch issue-224 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Changes to be committed: &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#   modified:   test.txt&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在使用 &lt;code&gt;pre-commit-msg&lt;/code&gt; 钩子时，需要记住的一点是在使用者通过 &lt;code&gt;-m&lt;/code&gt; 参数运行 &lt;code&gt;git commit&lt;/code&gt; 命令时本钩子依然会被执行。这就意味着在使用 &lt;code&gt;-m&lt;/code&gt; 输入提交信息的时候，上面的脚本会在提交信息里直接加入 &lt;code&gt;ISSUE-[#]&lt;/code&gt; 的内容，用户也没法编辑它。我们可以通过判断第二个参数（&lt;code&gt;commit_type&lt;/code&gt;）是否等于 &lt;code&gt;message&lt;/code&gt; 的方式来处理这个特殊情况。&lt;/p&gt;
&lt;p&gt;然后，在不带 &lt;code&gt;-m&lt;/code&gt; 参数的情况下，&lt;code&gt;prepare-commit-msg&lt;/code&gt; 钩子也会允许用户编辑自动生成的信息，所以这更多的是一个提供便利的脚本而非强制执行的提交政策。如果想要强制性的政策，我们需要在下一节讨论的 &lt;code&gt;commit-msg&lt;/code&gt; 钩子。&lt;/p&gt;
&lt;h2 id=&quot;提交信息钩子_Commit_Message&quot;&gt;提交信息钩子 Commit Message&lt;/h2&gt;&lt;p&gt;&lt;code&gt;commit-msg&lt;/code&gt; 钩子与 &lt;code&gt;prepare-commit-msg&lt;/code&gt; 很相似，但是这个钩子在用户输入提交信息 &lt;strong&gt;之后&lt;/strong&gt; 调用。这个钩子适宜用于警告开发者他们的提交信息不符合我们团队的标准。&lt;/p&gt;
&lt;p&gt;传递给这个钩子的唯一参数就是包含提交信息的临时文件名，如果钩子不喜欢用户输入的信息，它就会将改文件替换（与 &lt;code&gt;prepare-commit-msg&lt;/code&gt; 的行为一样）或者以非零状态退出从而终止整个提交。&lt;/p&gt;
&lt;p&gt;举例来说，下面的脚本检查并确保用户不能删除上一节所述的 &lt;code&gt;prepare-commit-msg&lt;/code&gt; 钩子自动生成的 issue 号 &lt;code&gt;ISSUE-[#]&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#!/usr/bin/env python&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; sys, os, re&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; subprocess &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; check_output&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 收集参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;commit_msg_filepath = sys.argv[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 找出当前所在分支&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;branch = check_output([&lt;span class=&quot;string&quot;&gt;&#39;git&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;symbolic-ref&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;--short&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;HEAD&#39;&lt;/span&gt;]).strip()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;commit-msg: On branch &#39;%s&#39;&quot;&lt;/span&gt; % branch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 如果我们在 issue 分支上，进行提交信息的检查&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; branch.startswith(&lt;span class=&quot;string&quot;&gt;&#39;issue-&#39;&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;commit-msg: Oh hey, it&#39;s an issue branch.&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    result = re.match(&lt;span class=&quot;string&quot;&gt;&#39;issue-(.*)&#39;&lt;/span&gt;, branch)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    issue_number = result.group(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    required_message = &lt;span class=&quot;string&quot;&gt;&quot;ISSUE-%s&quot;&lt;/span&gt; % issue_number&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; open(commit_msg_filepath, &lt;span class=&quot;string&quot;&gt;&#39;r&#39;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; f:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        content = f.read()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; content.startswith(required_message):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;commit-msg: ERROR! The commit message must start with &#39;%s&#39;&quot;&lt;/span&gt; % required_message&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            sys.exit(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于用户每创建一个提交时，该脚本就会被调用，所以我们还是应该避免对提交信息进行过多的检查。如果在有新提交时，需要通知其他服务，那么我们应该使用下面的 &lt;code&gt;post-commit&lt;/code&gt; 钩子。&lt;/p&gt;
&lt;h2 id=&quot;提交后钩子_Post-Commit&quot;&gt;提交后钩子 Post-Commit&lt;/h2&gt;&lt;p&gt;&lt;code&gt;post-commit&lt;/code&gt; 钩子在 &lt;code&gt;commit-msg&lt;/code&gt; 钩子之后立即出发。其可以改变 &lt;code&gt;git commit&lt;/code&gt; 命令的输出，因此主要被用作通知提醒。&lt;/p&gt;
&lt;p&gt;本脚本没有参数传入，且它的退出状态也不会影响到提交。对于大多数 &lt;code&gt;post-commit&lt;/code&gt; 钩子来说，我们都希望能够访问刚刚创建的那个提交。我们可以使用 &lt;code&gt;git rev-parse HEAD&lt;/code&gt; 来获取最新提交的 SHA1 哈希值，或者使用 &lt;code&gt;git log -l&lt;/code&gt; 来获取它的所有信息。&lt;/p&gt;
&lt;p&gt;举个例子，如果我们想要在每次提交快照时给我们的领导发个邮件（但如果这样做可能会被领导揍一顿……），就可以添加下面的 &lt;code&gt;post-commit&lt;/code&gt; 钩子：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#!/usr/bin/env python&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; smtplib&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; email.mime.text &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; MIMEText&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; subprocess &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; check_output&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Get the git log --stat entry of the new commit&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;log = check_output([&lt;span class=&quot;string&quot;&gt;&#39;git&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;log&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;-1&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;--stat&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;HEAD&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Create a plaintext email message&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;msg = MIMEText(&lt;span class=&quot;string&quot;&gt;&quot;Look, I&#39;m actually doing some work:\n\n%s&quot;&lt;/span&gt; % log)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;msg[&lt;span class=&quot;string&quot;&gt;&#39;Subject&#39;&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;&#39;Git post-commit hook notification&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;msg[&lt;span class=&quot;string&quot;&gt;&#39;From&#39;&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;&#39;mary@example.com&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;msg[&lt;span class=&quot;string&quot;&gt;&#39;To&#39;&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;&#39;boss@example.com&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Send the message&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SMTP_SERVER = &lt;span class=&quot;string&quot;&gt;&#39;smtp.example.com&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SMTP_PORT = &lt;span class=&quot;number&quot;&gt;587&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;session = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;session.ehlo()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;session.starttls()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;session.ehlo()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;session.login(msg[&lt;span class=&quot;string&quot;&gt;&#39;From&#39;&lt;/span&gt;], &lt;span class=&quot;string&quot;&gt;&#39;secretPassword&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;session.sendmail(msg[&lt;span class=&quot;string&quot;&gt;&#39;From&#39;&lt;/span&gt;], msg[&lt;span class=&quot;string&quot;&gt;&#39;To&#39;&lt;/span&gt;], msg.as_string())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;session.quit()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以使用 &lt;code&gt;post-commit&lt;/code&gt; 来触发一个本地 &lt;strong&gt;持续集成系统&lt;/strong&gt; &lt;sup&gt;&lt;a href=&quot;#note-2&quot;&gt;注2&lt;/a&gt;&lt;/sup&gt;，但是大多数时间我们会把这件事放在 &lt;code&gt;post-receive&lt;/code&gt; 钩子里。这个钩子跑在服务端而非本地，且 &lt;strong&gt;每当&lt;/strong&gt; 有开发者提交代码的时候都会运行，因此这里更加适合部署我们的持续集成系统。&lt;/p&gt;
&lt;h2 id=&quot;切换后钩子_Post-Checkout&quot;&gt;切换后钩子 Post-Checkout&lt;/h2&gt;&lt;p&gt;&lt;code&gt;post-checkout&lt;/code&gt; 钩子工作机制与 &lt;code&gt;post-commit&lt;/code&gt; 钩子很像，其触发时机是每次我们使用 &lt;code&gt;git checkout&lt;/code&gt; 切换到一个新引用上。它大可用在清理你工作目录生成的文件，尽管这么用可能会让人困惑。&lt;/p&gt;
&lt;p&gt;这个钩子接受三个参数，它的退出状态不会影响到 &lt;code&gt;git checkout&lt;/code&gt; 命令。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;之前 &lt;code&gt;HEAD&lt;/code&gt; 的引用&lt;/li&gt;
&lt;li&gt;新 &lt;code&gt;HEAD&lt;/code&gt; 的引用&lt;/li&gt;
&lt;li&gt;一个标志，告诉我们切换的是分支还是文件，分支是 1，文件是 0。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通常 Python 开发者们都会遇到一个蛋疼的问题：在切换分支的时候，之前生成的各种 &lt;code&gt;.pyc&lt;/code&gt; 文件依然留在工作区内。解释器有时使用 &lt;code&gt;.pyc&lt;/code&gt; 而非 &lt;code&gt;.py&lt;/code&gt; 作为源文件。为了避免混乱，我们可以使用下面的钩子在每次切换新分支的时候清理所有的 &lt;code&gt;.pyc&lt;/code&gt; 文件：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#!/usr/bin/env python&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; sys, os, re&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; subprocess &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; check_output&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Collect the parameters&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;previous_head = sys.argv[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;new_head = sys.argv[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;is_branch_checkout = sys.argv[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; is_branch_checkout == &lt;span class=&quot;string&quot;&gt;&quot;0&quot;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;post-checkout: This is a file checkout. Nothing to do.&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sys.exit(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;post-checkout: Deleting all &#39;.pyc&#39; files in working directory&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; root, dirs, files &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; os.walk(&lt;span class=&quot;string&quot;&gt;&#39;.&#39;&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; filename &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; files:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ext = os.path.splitext(filename)[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ext == &lt;span class=&quot;string&quot;&gt;&#39;.pyc&#39;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            os.unlink(os.path.join(root, filename))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于钩子脚本来说，当前工作目录永远被设定为仓库根目录，因此 &lt;code&gt;os.walk(&amp;#39;.&amp;#39;)&lt;/code&gt; 可以遍历仓库中的每一个文件。然后我们就可以删掉哪些后缀名是 &lt;code&gt;.pyc&lt;/code&gt; 的文件啦。&lt;/p&gt;
&lt;p&gt;我们也可以使用 &lt;code&gt;post-checkout&lt;/code&gt; 钩子基于已经切换到的分支来改变工作目录。例如我们可能使用一个叫做 &lt;code&gt;plugins&lt;/code&gt; 的分支来存储核心代码之外的各种插件。如果这些插件体积不小，且其他的分支并不需要，我们就可以仅在切换到 &lt;code&gt;plugins&lt;/code&gt; 分支时才有选择的进行插件构建。&lt;/p&gt;
&lt;h2 id=&quot;预衍合钩子_Pre-Rebase&quot;&gt;预衍合钩子 Pre-Rebase&lt;/h2&gt;&lt;p&gt;&lt;code&gt;pre-rebase&lt;/code&gt; 钩子在使用 &lt;code&gt;git rebase&lt;/code&gt; 命令做任何改变之前触发，本钩子可以很好的确保一些糟糕情况的发生。&lt;/p&gt;
&lt;p&gt;钩子有两个参数：分岔起点的上游分支和正在被衍合的分支。当衍合当前分支时，第二个参数为空。脚本以非零状态退出会终止衍合。&lt;/p&gt;
&lt;p&gt;例如，如果我们在项目中完全不允许衍合，可以使用下面的钩子：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;shebang&quot;&gt;#!/bin/sh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Disallow all rebasing&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;pre-rebase: Rebasing is dangerous. Don&#39;t do it.&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在每当我们运行 &lt;code&gt;git rebase&lt;/code&gt; 都会看到下面的信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pre-rebase: Rebasing &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; dangerous. Don&#39;t do &lt;span class=&quot;keyword&quot;&gt;it&lt;/span&gt;.
The pre-rebase hook refused &lt;span class=&quot;keyword&quot;&gt;to&lt;/span&gt; rebase.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果想看更深入一点的例子，推荐研究自带的 &lt;code&gt;pre-rebase.sample&lt;/code&gt; 脚本。这个脚本更加睿智一点，会在特定的情况下拒绝衍合。它会严查你准备衍合的分支是否已经合并到主线分支上。如果已合并，再进行衍合就会产生混乱，因此脚本就会拒绝衍合。&lt;/p&gt;
&lt;h1 id=&quot;服务端钩子&quot;&gt;服务端钩子&lt;/h1&gt;&lt;p&gt;服务端钩子和本地钩子的工作机制相同，区别仅在于其部署在服务端仓库（例如中央仓库或开发者的公共仓库）。由于部署在这种官方仓库，一些服务端钩子可以作为一种强制政策来拒绝一些特定提交。&lt;/p&gt;
&lt;p&gt;下文中我们将讨论三种服务端钩子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pre-receive&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;update&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;post-receive&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有的这些钩子都是为了让我们能够在 Git 推送的不同阶段做出反应。&lt;/p&gt;
&lt;p&gt;服务端钩子的输出会显示在客户端控制台上，因此将信息返回给开发者十分容易。但是我们应该记住这些脚本在结束执行之前不会返回终端的控制权，因此我们应该慎重处理那些运行时间较长的操作。&lt;/p&gt;
&lt;h2 id=&quot;预接收钩子_Pre-Receive&quot;&gt;预接收钩子 Pre-Receive&lt;/h2&gt;&lt;p&gt;&lt;code&gt;pre-receive&lt;/code&gt; 钩子在每次有用户执行 &lt;code&gt;git push&lt;/code&gt; 来推送提交到仓库中时都会被执行。其仅能存在于那些作为推送目标的 &lt;strong&gt;远端仓库&lt;/strong&gt;，而非在原始仓库。&lt;/p&gt;
&lt;p&gt;钩子在每次引用被更新之前都会运行，因此适合按照我们的意愿做成强制执行的开发政策。如果我们不希望某人进行推送，或者不喜欢某些提交信息的格式和提交内容，我们都可以使用这个钩子拒绝推送。尽管我们不能阻止开发者搞出一些乱七八糟的提交，但至少能使用 &lt;code&gt;pre-receive&lt;/code&gt; 阻挡这些难看的提交进入中央仓库。&lt;/p&gt;
&lt;p&gt;本脚本不传入参数，但是每个正在被推送的引用都通过标准输入的方式分行传入脚本，格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;old-value&amp;gt; &amp;lt;new-value&amp;gt; &amp;lt;&lt;span class=&quot;keyword&quot;&gt;ref&lt;/span&gt;-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以通过最基本的 &lt;code&gt;pre-receive&lt;/code&gt; 脚本来看到本钩子是怎么工作的，下面的脚本仅仅是读入了引用内容并进行了输出：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#!/usr/bin/env python&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; sys&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; fileinput&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Read in each ref that the user is trying to update&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; fileinput.input():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;pre-receive: Trying to push ref: %s&quot;&lt;/span&gt; % line&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Abort the push&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# sys.exit(1)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不过，这里还是跟其他的钩子略有不同，因为信息是通过标准输入而非命令行参数传入的。当将本钩子防止到远端仓库的 &lt;code&gt;.git/hooks&lt;/code&gt; 中，并对 &lt;code&gt;master&lt;/code&gt; 分支进行推送时，我们就会看到如下信息出现在控制台上：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;b&lt;span class=&quot;number&quot;&gt;6b36c697&lt;/span&gt;eb&lt;span class=&quot;number&quot;&gt;2d24302f89&lt;/span&gt;aa22d9170dfe609855b 85baa88c22b52ddd24d71f05db&lt;span class=&quot;number&quot;&gt;31f4e46d57&lt;/span&gt;9095 refs/heads/master
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以使用这些 SHA1 哈希值和一些底层 Git 命令，来检查即将生成的改动，通常有以下的用法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拒绝包含衍合了上游分支的提交；&lt;/li&gt;
&lt;li&gt;阻止非快进合并；&lt;/li&gt;
&lt;li&gt;检查用户是否有权限来进行某些修改（多用于中央化的 Git 工作流）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果多个引用被提交，返回非零状态会取消全部的引用。如果我们想按照具体提交来接受或拒绝分支，就需要使用 &lt;code&gt;update&lt;/code&gt; 钩子。&lt;/p&gt;
&lt;h2 id=&quot;更新钩子_Update&quot;&gt;更新钩子 Update&lt;/h2&gt;&lt;p&gt;&lt;code&gt;update&lt;/code&gt; 钩子在 &lt;code&gt;pre-receive&lt;/code&gt; 之后被调用，工作原理差不多。其也会在所有东西被真实提交之前执行，但却分别为每一个推送的引用而调用。意思是说如果用户尝试推送四个分支，&lt;code&gt;update&lt;/code&gt; 钩子就会尝试执行四次。与 &lt;code&gt;pre-receive&lt;/code&gt; 不同的是，该钩子不需要读入标准输入，想法其接受如下的三个参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正在更新的引用名称；&lt;/li&gt;
&lt;li&gt;分支引用中存储的旧提交对象；&lt;/li&gt;
&lt;li&gt;分支引用中存储的新提交对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这与传递给 &lt;code&gt;pre-receive&lt;/code&gt; 钩子的信息相同，但是由于 &lt;code&gt;update&lt;/code&gt; 在每一个分支更新时都会被触发，我们可以拒绝一部分分支而允许其他的分支提交。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#!/usr/bin/env python&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; sys&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;branch = sys.argv[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;old_commit = sys.argv[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;new_commit = sys.argv[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Moving &#39;%s&#39; from %s to %s&quot;&lt;/span&gt; % (branch, old_commit, new_commit)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Abort pushing only this branch&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# sys.exit(1)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的 &lt;code&gt;update&lt;/code&gt; 钩子仅仅输出了分支名和新旧提交哈希值。当给远端的仓库推送多个分支时，我们可以看到每个分支都执行了一次 &lt;code&gt;print&lt;/code&gt; 语句。&lt;/p&gt;
&lt;h2 id=&quot;接受后钩子_Post-Receive&quot;&gt;接受后钩子 Post-Receive&lt;/h2&gt;&lt;p&gt;&lt;code&gt;post-receive&lt;/code&gt; 钩子在成功推送之后调用，适宜用作进行消息提示。对许多工作流来说，本钩子比 &lt;code&gt;post-commit&lt;/code&gt; 更适合触发通知，因为钩子放在公共服务器上改起来方便，分发给每一个用户放在本地机器上改都没法改。在持续集成系统里，经常使用 &lt;code&gt;post-receive&lt;/code&gt; 钩子给其他开发者发邮件。&lt;/p&gt;
&lt;p&gt;本钩子没有参数，但是会从标准输入接入与 &lt;code&gt;pre-receive&lt;/code&gt; 一样的输入参数。&lt;/p&gt;
&lt;h1 id=&quot;总结&quot;&gt;总结&lt;/h1&gt;&lt;p&gt;通过本文我们学习了如何使用 Git 钩子改变内部行为以及项目中特定事件触发时进行通知。钩子就是放置在 &lt;code&gt;.git/hooks&lt;/code&gt; 路径下的普通脚本，这使得他们易于安装和制定。&lt;/p&gt;
&lt;p&gt;我们也研究了一些最普通的本地及服务端钩子，这使得我们可以在整个开发的生命周期中插入操作。我们现在知道了如何在提交创建、推送过程的每一步中执行自定义操作。只需要懂一点脚本知识，我们就可以对 Git 仓库做很多想做的事情。&lt;/p&gt;
&lt;h1 id=&quot;注释&quot;&gt;注释&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;b id=&quot;note-1&quot;&gt;注1：&lt;/b&gt;exit 命令一般用于结束一个脚本，能返回一个值给父进程，执行成功的话这个值会是 0，因此非零退出表示脚本执行失败。如果一个脚本以不带参数的 exit 命令结束，脚本的退出状态码将会是执行 exit 命令前的最后一个命令的退出码（用 &lt;code&gt;$?&lt;/code&gt; 表示），详见：&lt;a href=&quot;http://shouce.jb51.net/shell/exit-status.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;退出和退出状态&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;b id=&quot;note-2&quot;&gt;注2：&lt;/b&gt;持续集成是一种软件项目管理方法，依据资产库（源码，类库等）的变更自动完成编译、测试、部署和反馈，详见阮老师的博文：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;什么是持续集成系统？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xinjg.com1.z0.glb.clouddn.com/git-tips-hookhero.svg&quot; alt=&quot;Git 钩子&quot;&gt;&lt;/p&gt;
&lt;p&gt;Git 钩子是在一个 Git 仓库中，在每一次特定事件触发时自动运行的脚本。它允许我们自定义 Git 的内部行为，并在开发的生命周期的关键时间点触发自定义行为。&lt;/p&gt;
    
    </summary>
    
      <category term="Git魔导之路" scheme="http://malcolmyu.github.io/malnote/categories/Git%E9%AD%94%E5%AF%BC%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Git" scheme="http://malcolmyu.github.io/malnote/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>使用分支</title>
    <link href="http://malcolmyu.github.io/malnote/2015/10/05/Using-Branches/"/>
    <id>http://malcolmyu.github.io/malnote/2015/10/05/Using-Branches/</id>
    <published>2015-10-04T16:00:00.000Z</published>
    <updated>2015-10-11T10:26:10.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xinjg.com1.z0.glb.clouddn.com/git-coll-brhero.svg&quot; alt=&quot;使用分支&quot;&gt;&lt;/p&gt;
&lt;p&gt;这篇教程对 Git 的分支进行了全面详尽的介绍。首先我们会研究下如何新建分支，其过程和获取一个新的项目历史有点类似；之后我们会了解到如何使用 &lt;code&gt;git checkout&lt;/code&gt; 来选择分支；最后我们会学习到 &lt;code&gt;git merge&lt;/code&gt; 命令是如何将几个相互独立的分支上进行整合的。&lt;/p&gt;
&lt;p&gt;在阅读文本时，请记住 Git 的分支与 SVN 分支的不同。SVN 的分支是用来处理偶尔会进行的大规模开发才使用的，而 Git 的分支确是我们日常工作流不可或缺的一部分。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;git_branch&quot;&gt;git branch&lt;/h1&gt;&lt;p&gt;一个分支就是开发中的一条独立的路线。Git 的基本过程包含：编辑/暂存/提交，这一点我们之前在『保存更改』一节中有所提及。而分支作为 Git 最基本过程的抽象，是本节的首要模块。我们可以认为分支就是一种获取崭新工作目录、暂存区和项目历史的一种方式。新的提交记录在当前分支的历史上，同时也记录在整个项目历史的分岔之中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git branch&lt;/code&gt; 命令允许我们创建、展示、重命名和删除分支，却不允许我们在不同的分支之间进行切换，或者将一个分岔的历史记录接回主干上。因此 &lt;code&gt;git branch&lt;/code&gt; 命令需要与 &lt;code&gt;git checkout&lt;/code&gt; 命令以及 &lt;code&gt;git merge&lt;/code&gt; 命令紧密结合使用。&lt;/p&gt;
&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;title&quot;&gt;git&lt;/span&gt; branch
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该命令表示展示当前仓库的所有分支。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;label&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;branch &lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;branch&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该命令表示创建一个叫做 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 的新分支，但 &lt;strong&gt;不会&lt;/strong&gt; 检出到新分支上。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;label&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;branch &lt;/span&gt;-d &amp;lt;&lt;span class=&quot;keyword&quot;&gt;branch&amp;gt; &lt;/span&gt;   
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该命令表示删除一个指定分支。这是一个安全的操作，因为 Git 不允许我们删除哪些还有没合并更改的分支。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;label&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;branch &lt;/span&gt;-D &amp;lt;&lt;span class=&quot;keyword&quot;&gt;branch&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该命令表示强制删除指定的分支，不考虑该分支是否有没合并的更改。这条命令的使用场景是我们想彻底抛弃某条开发路线上的所有提交。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;label&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;branch &lt;/span&gt;-m &amp;lt;&lt;span class=&quot;keyword&quot;&gt;branch&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将当前分支重命名为 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;详述&quot;&gt;详述&lt;/h2&gt;&lt;p&gt;在 Git 中，分支是我们每天开发过程的一部分。当我们想要添加一个新特性或修复一个 bug，不管这改动大还是小，我们都需要产生一个新分支并在上面封装我们的改动。这确保了不稳定的代码永远不会被提交到主干代码上，并给予我们在将代码和并到主干之前整合分支历史的机会。&lt;/p&gt;
&lt;p&gt;&lt;image src=&quot;http://7xinjg.com1.z0.glb.clouddn.com/git-coll-br01.svg&quot; width=&quot;80%&quot;&gt;&lt;/image&gt;&lt;/p&gt;

&lt;p&gt;例如上图展示了一个拥有两条独立开发路线的仓库，一条是一个小特性，另一条是一个需要长期开发的特性。通过在分支中开发这些特性，不仅可以保证它们的开发得以并行，同时也保证了主分支 &lt;code&gt;master&lt;/code&gt; 上不会产生有问题的代码。&lt;/p&gt;
&lt;h3 id=&quot;分支指针&quot;&gt;分支指针&lt;/h3&gt;&lt;p&gt;Git 分支背后的实现相比 SVN 的实现模式更加轻量。Git 将分支存储为对一个提交的引用，而非 SVN 式的将文件从一个目录拷贝到另一个目录。换言之，一个分支表示了对一系列提交的 &lt;strong&gt;指针&lt;/strong&gt;，而非提交的 &lt;strong&gt;容器&lt;/strong&gt;。分支的历史是通过提交的关系推断的出的。&lt;/p&gt;
&lt;p&gt; 这对于 Git 合并模型有着戏剧性的影响。在 SVN 中合并是基于文件的，而 Git 让合并基于提交这一更加抽象的层面上。我们可以在项目历史中确切的看到：合并是作为两个独立的提交历史的连接的。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;示例&lt;/h2&gt;&lt;h3 id=&quot;创建分支&quot;&gt;创建分支&lt;/h3&gt;&lt;p&gt;重要的一点是了解分支仅仅是指向提交的的 &lt;strong&gt;指针&lt;/strong&gt;。当我们创建一个分支的时候，Git 仅需要创建一个新指针——而不会对仓库产生其他的更改。因此如果我们的仓库看上去如下所示：&lt;/p&gt;
&lt;p&gt;&lt;image src=&quot;http://7xinjg.com1.z0.glb.clouddn.com/git-coll-br02.svg&quot; width=&quot;80%&quot;&gt;&lt;/image&gt;&lt;/p&gt;

&lt;p&gt;然后我们使用下面的命令创建分支：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;label&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;branch &lt;/span&gt;crazy-experiment
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;分支历史依然没有任何更改，我们的到的仅仅是一个指向当前提交的新指针：&lt;/p&gt;
&lt;p&gt;&lt;image src=&quot;http://7xinjg.com1.z0.glb.clouddn.com/git-coll-br03.svg&quot; width=&quot;80%&quot;&gt;&lt;/image&gt;&lt;/p&gt;

&lt;p&gt;注意到这一操作仅仅 &lt;strong&gt;创建了&lt;/strong&gt; 新分支。如果想要在新分支上添加提交，我们需要使用 &lt;code&gt;git checkout&lt;/code&gt; 命令选择它，并使用标准的 &lt;code&gt;git add&lt;/code&gt; 和 &lt;code&gt;git commit&lt;/code&gt; 命令，更多信息请参阅下一章节 git checkout。&lt;/p&gt;
&lt;h3 id=&quot;删除分支&quot;&gt;删除分支&lt;/h3&gt;&lt;p&gt;当我们结束在一个分支上的工作并将其合并到主干代码上是，我们就可以自由的删除分支而不丢失任何历史记录：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;label&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;branch &lt;/span&gt;-d crazy-experiment
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然而，如果该分支还没有被合并，上面的命令会输出如下的信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;attribute&quot;&gt;error&lt;/span&gt;: The branch &lt;span class=&quot;string&quot;&gt;&#39;crazy-experiment&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; fully merged.
If you are sure you want &lt;span class=&quot;keyword&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;it&lt;/span&gt;, run &lt;span class=&quot;string&quot;&gt;&#39;git branch -D crazy-experiment&#39;&lt;/span&gt;.    
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这就防止了我们丢失对于这些提交的引用，丢失引用意味着我们会失去有效的进入整个开发路线的手段。如果我们确实想删除整个分支，我们可以使用大写的 &lt;code&gt;-D&lt;/code&gt; 参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;label&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;branch &lt;/span&gt;-D crazy-experiment
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这将会无视分支的状态，且不输出警告地删除分支，请审慎使用这一命令。&lt;/p&gt;
&lt;h1 id=&quot;git_checkout&quot;&gt;git checkout&lt;/h1&gt;&lt;p&gt;&lt;code&gt;git checkout&lt;/code&gt; 命令让我们在使用 &lt;code&gt;git branch&lt;/code&gt; 命令建立的分支之间切换。检出一个分支使用存储在该分支的版本的文件来更新工作目录，并且告知 Git 将所有新提交记录到该分支上。我们可以把这想象成一种选择我们当前工作路线的方式。&lt;/p&gt;
&lt;p&gt;在上一章中，我们了解了 &lt;code&gt;git checkout&lt;/code&gt; 是如何被用作检查旧有提交的。检出分支的操作有点像是将工作区更新到选择的分支或者版本的状态；同时新带的更改会被保存到项目历史中，也就是说，这不是一个只读的操作。&lt;/p&gt;
&lt;h2 id=&quot;使用-1&quot;&gt;使用&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;git checkout &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;existing-branch&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;检出制定的分支，这一分支必须已经被 &lt;code&gt;git branch&lt;/code&gt; 命令创建。&lt;code&gt;&amp;lt;existing-branch&amp;gt;&lt;/code&gt; 会成为当前分支，且会将工作目录更新至匹配状态。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout -&lt;span class=&quot;tag&quot;&gt;b&lt;/span&gt; &amp;lt;new-branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建并检出到 &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt;。&lt;code&gt;-b&lt;/code&gt; 是一个方便的参数，会告诉 Git 在运行 &lt;code&gt;git branch &amp;lt;new-branch&amp;gt;&lt;/code&gt; 之前运行 &lt;code&gt;git checkout &amp;lt;new-branch&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;label&quot;&gt;git&lt;/span&gt; checkout -&lt;span class=&quot;keyword&quot;&gt;b &lt;/span&gt;&amp;lt;new-&lt;span class=&quot;keyword&quot;&gt;branch&amp;gt; &lt;/span&gt;&amp;lt;existing-&lt;span class=&quot;keyword&quot;&gt;branch&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;和上一命令相同，不过检出的分支是基于 &lt;code&gt;&amp;lt;existing-branch&amp;gt;&lt;/code&gt; 而非当前分支。&lt;/p&gt;
&lt;h2 id=&quot;详述-1&quot;&gt;详述&lt;/h2&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xinjg.com1.z0.glb.clouddn.com/git-coll-brhero.svg&quot; alt=&quot;使用分支&quot;&gt;&lt;/p&gt;
&lt;p&gt;这篇教程对 Git 的分支进行了全面详尽的介绍。首先我们会研究下如何新建分支，其过程和获取一个新的项目历史有点类似；之后我们会了解到如何使用 &lt;code&gt;git checkout&lt;/code&gt; 来选择分支；最后我们会学习到 &lt;code&gt;git merge&lt;/code&gt; 命令是如何将几个相互独立的分支上进行整合的。&lt;/p&gt;
&lt;p&gt;在阅读文本时，请记住 Git 的分支与 SVN 分支的不同。SVN 的分支是用来处理偶尔会进行的大规模开发才使用的，而 Git 的分支确是我们日常工作流不可或缺的一部分。&lt;/p&gt;
    
    </summary>
    
      <category term="Git 魔导之路" scheme="http://malcolmyu.github.io/malnote/categories/Git-%E9%AD%94%E5%AF%BC%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Git" scheme="http://malcolmyu.github.io/malnote/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>协作同步</title>
    <link href="http://malcolmyu.github.io/malnote/2015/08/01/Collaborating-Syncing/"/>
    <id>http://malcolmyu.github.io/malnote/2015/08/01/Collaborating-Syncing/</id>
    <published>2015-07-31T16:00:00.000Z</published>
    <updated>2015-11-27T07:32:00.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xinjg.com1.z0.glb.clouddn.com/git-coll-synchero.svg&quot; alt=&quot;同步&quot;&gt;&lt;/p&gt;
&lt;p&gt;SVN 使用一个单独的中心仓库以作为开发者的通信枢纽，其协作的方式是开发者的工作副本与中央仓库互相发送变更记录。这与 Git 的协作模式有所不同，Git 中每个开发者都拥有仓库的副本，以及完整的本地历史和分支结构。用户通常只需要提供一系列的提交而不是单个的变更记录。Git 允许我们在仓库之间共享整个分支，而不是单单的从工作副本提交一个变更记录到中央仓库去。&lt;/p&gt;
&lt;p&gt;下面介绍的命令可以帮助我们管理与其他仓库的连接：我们可以使用“推送”分支的方式将本地历史发布到其他仓库，也可以使用“拉取”分支的方式将别人贡献的代码获取到本地。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;git_remote&quot;&gt;git remote&lt;/h1&gt;&lt;p&gt;&lt;code&gt;git remote&lt;/code&gt; 命令让我们可以创建、查看和删除与其他仓库的链接。远端链接不是直接连到别的仓库，它更像是一个书签一样的快捷方式：它并没有提供与其他仓库的实时连接，而是提供了一个方便好记的别名以指代那些不那么方便的 URL。&lt;/p&gt;
&lt;p&gt;比如下图就展示了从我们本地仓库链接到中央仓库和其他开发者仓库的两个链接。我们可以不用 URLs 全称来表示，而只用给其他的 Git 命令传递诸如 origin 和 john 这样的缩写就行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xinjg.com1.z0.glb.clouddn.com/git-coll-sync01.svg&quot; alt=&quot;git remote 示例&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;title&quot;&gt;git&lt;/span&gt; remote
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;展示你与其他仓库之间的全部远端链接（仅有别名）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;title&quot;&gt;git&lt;/span&gt; remote -v
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与上条命令相同，不过带上了每个链接的 URL。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git remote add &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;url&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建一个连接到新远端仓库的链接。添加链接之后，我们就可以在其他的 Git 命令中方便地使用 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 作为指代 url 的简写。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git remote rm &amp;lt;&lt;span class=&quot;property&quot;&gt;name&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;删除名为 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 的远端链接。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git remote &lt;span class=&quot;operator&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;rename&lt;/span&gt; &amp;lt;&lt;span class=&quot;keyword&quot;&gt;old&lt;/span&gt;-&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;&amp;gt; &amp;lt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;-&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将一个名为 &lt;code&gt;&amp;lt;old-name&amp;gt;&lt;/code&gt; 的链接重命名为 &lt;code&gt;&amp;lt;new-name&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;详述&quot;&gt;详述&lt;/h2&gt;&lt;p&gt;Git 的设计初衷是给每一位开发者一个完整而独立的开发环境，这就意味着    信息不能自动的在库间传递。相反，开发者需要手动的将上游提交拉取到本地，或者手动的将本地提交推送会中央仓库。&lt;code&gt;git remote&lt;/code&gt; 命令仅仅就是一个给那些带有“共享”性质的 Git 命令（&lt;strong&gt;译者注：&lt;/strong&gt;如本文后面讲解的 &lt;code&gt;push&lt;/code&gt; &lt;code&gt;pull&lt;/code&gt; 命令等）传递 URL 的一个便捷方式。&lt;/p&gt;
&lt;h3 id=&quot;origin_远端&quot;&gt;origin 远端&lt;/h3&gt;&lt;p&gt;当你使用 &lt;code&gt;git clone&lt;/code&gt; 命令克隆一个仓库时，Git 会自动创建一个叫做 origin 的远程链接指向被克隆的仓库。这对开发者来说十分有益：当我们在本地创建一个中央仓库的副本时，可以便捷的推动本地提交或拉取远端修改。这也是大多数基于 Git 的项目管中央仓库叫“origin”的原因。&lt;/p&gt;
&lt;h3 id=&quot;仓库_URLs&quot;&gt;仓库 URLs&lt;/h3&gt;&lt;p&gt;Git 提供了许多方式以作为远端仓库的引用。两个最常用的方式就是通过 HTTP 协议和 SSH 协议。HTTP 是对仓库进行匿名且只有只读权限的访问的一条便捷方式，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;symbol&quot;&gt;http:&lt;/span&gt;/&lt;span class=&quot;regexp&quot;&gt;/host/path&lt;/span&gt;&lt;span class=&quot;regexp&quot;&gt;/to/repo&lt;/span&gt;.git
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是通常情况下给一个 HTTP 地址推送提交是不太可能的（我们应该也不会允许匿名用户推送提交）。我们应该使用 SSH 协议以获取读写权限：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh://user&lt;span class=&quot;constant&quot;&gt;@host&lt;/span&gt;/path/&lt;span class=&quot;keyword&quot;&gt;to&lt;/span&gt;/repo.git
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们在主机上需要有一个可用的 SSH 账号，除此之外，Git 也支持带有权限校验的访问（SSH 自带的）。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;示例&lt;/h3&gt;&lt;p&gt;除了 origin 以外，连接同事的仓库也是十分方便的。例如你的好基友 John 维护着一个地址是 &lt;code&gt;dev.example.com/john.git&lt;/code&gt; 公用仓库，你就可以这样添加一个链接：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git remote add john &lt;span class=&quot;string&quot;&gt;http:&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;//dev.example.com/john.git&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过这种到个人开发者仓库的连接方式，使中央仓库之外的协作成为可能。这对于小团队开发大项目来说十分有用。&lt;/p&gt;
&lt;h1 id=&quot;git_fetch&quot;&gt;git fetch&lt;/h1&gt;&lt;p&gt;&lt;code&gt;git fetch&lt;/code&gt; 命令从远端仓库将提交导入到本地。导入的提交已然存储在远端分支而非我们工作的本地分支。这让我们在将远端提交整合到本地之前可以有机会审核一下代码。&lt;/p&gt;
&lt;h2 id=&quot;使用-1&quot;&gt;使用&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;git fetch &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;remote&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;拉取该仓库的全部分支，这一操作也会把所有必要的提交和文件都下载下来。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git fetch &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;remote&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;branch&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;和上一命令类似，但仅拉取特定的分支。&lt;/p&gt;
&lt;h2 id=&quot;详述-1&quot;&gt;详述&lt;/h2&gt;&lt;p&gt;当我们想查看其他人的工作时，可以采用 fetch 操作。既然 fetch 的参数代表着一个远端分支，那这一操作就对本地开发工作完全没有影响。fetch 为我们提供了一种不整合、先审核的安全的审核提交的方式。这有点像 svn update，它让我们看到中央仓库的历史情况，却不强制我们实际将更改并入本地仓库。&lt;/p&gt;
&lt;h3 id=&quot;远端分支&quot;&gt;远端分支&lt;/h3&gt;&lt;p&gt;远端分支和本地分支很像，只不过远端包含了来自其他人仓库的提交。我们可以像查看本地分支一样查看远端分支，但是这会使我们的工程进入“分离头指针”的状态（正如检出到一个旧有提交的状态一样），我们可以将其当做一个只读的分支。想要查看远端分支，我们只需要给 &lt;code&gt;git branch&lt;/code&gt; 命令加上一个 &lt;code&gt;-r&lt;/code&gt; 参数。远端的分支会以远端的别名作为前缀，因此我们不会把它们和本地分支弄混。下面这个例子就展示了我们在获取 origin 的远端时可能看到的分支：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git branch -r
&lt;span class=&quot;preprocessor&quot;&gt;# origin/master&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;# origin/develop&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;# origin/some-feature&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后我们可以通过 &lt;code&gt;git checkout&lt;/code&gt; 和 &lt;code&gt;git log&lt;/code&gt; 的命令来检视这些分支。如果我们觉得一个远端分支的更改靠谱，就可以使用 &lt;code&gt;git merge&lt;/code&gt; 命令将它整合到一个本地分支。与 SVN 不同的是，同步远端分支到本地的操作是 fetch 和 merge 两个过程。但 Git 却可以方便的使用 &lt;code&gt;git pull&lt;/code&gt; 命令来完成这两个过程。&lt;/p&gt;
&lt;h2 id=&quot;示例-1&quot;&gt;示例&lt;/h2&gt;&lt;p&gt;这一示例展示了同步中央仓库的 &lt;code&gt;master&lt;/code&gt; 分支到本地仓库这一典型工作流程。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;title&quot;&gt;git&lt;/span&gt; fetch origin 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这一步会展示已下载的分支们：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a1e8fb5..&lt;span class=&quot;number&quot;&gt;45&lt;/span&gt;e66a4 &lt;span class=&quot;keyword&quot;&gt;master&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;-&amp;gt; origin&lt;/span&gt;/&lt;span class=&quot;keyword&quot;&gt;master&lt;/span&gt;
&lt;span class=&quot;title&quot;&gt;a1e8fb5&lt;/span&gt;..&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;e8ab1c develop -&amp;gt; origin/develop
* [new branch] some-feature -&amp;gt; origin/some-feature
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从新的远端分支获取的提交们在下表中以方块显示，而之前在本地的提交以圆圈显示。如图所示， &lt;code&gt;git fetch&lt;/code&gt; 使我们访问到另一个仓库的全部分支结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xinjg.com1.z0.glb.clouddn.com/git-coll-sync02.svg&quot; alt=&quot;git fetch 获取远端分支结构&quot;&gt;    &lt;/p&gt;
&lt;p&gt;想查看上游的 master 分支添加了哪些提交，我们可以使用 &lt;code&gt;git log&lt;/code&gt; 命令，并添加 &lt;code&gt;origin/master&lt;/code&gt; 的过滤器。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git &lt;span class=&quot;command&quot;&gt;log&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;--oneline master..origin/master&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用如下的命令可以将我们认可的分支合并到我们本地的 &lt;code&gt;master&lt;/code&gt; 分支上：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout &lt;span class=&quot;keyword&quot;&gt;master&lt;/span&gt;
&lt;span class=&quot;title&quot;&gt;git&lt;/span&gt; log origin/&lt;span class=&quot;keyword&quot;&gt;master&lt;/span&gt;    &lt;span class=&quot;title&quot;&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后我们便可以使用 &lt;code&gt;git merge&lt;/code&gt; 命令合并 &lt;code&gt;origin/master&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git &lt;span class=&quot;operator&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;merge&lt;/span&gt; origin/&lt;span class=&quot;keyword&quot;&gt;master&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在 origin/master 和本地的 master 分支都指向了同一提交，我们已经完成了与上游开发内容的同步。&lt;/p&gt;
&lt;h1 id=&quot;git_pull&quot;&gt;git pull&lt;/h1&gt;&lt;p&gt;将上游更改合并到本地仓库在基于 Git 的协作工作流中是一个常见的操作。我们已经知道如何用 &lt;code&gt;git fetch&lt;/code&gt; 和 &lt;code&gt;git merge&lt;/code&gt; 来完成这一操作，但是 &lt;code&gt;git pull&lt;/code&gt; 将这两部操作整合为一个命令。    &lt;/p&gt;
&lt;h2 id=&quot;使用-2&quot;&gt;使用&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;git pull &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;remote&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这一命令表示获取制定的当前分支的远端副本并将其立即合并到本地副本中。这一命令与先 &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; 然后 &lt;code&gt;git merge origin/&amp;lt;current-branch&amp;gt;&lt;/code&gt; 效用相同。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git pull &lt;span class=&quot;comment&quot;&gt;--rebase &amp;lt;remote&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;和上一命令相同，不过不是使用 &lt;code&gt;git merge&lt;/code&gt; 来整合远端分支，而是使用 &lt;code&gt;git rebase&lt;/code&gt;。    &lt;/p&gt;
&lt;h2 id=&quot;详述-2&quot;&gt;详述&lt;/h2&gt;&lt;p&gt;我们可以把 &lt;code&gt;git pull&lt;/code&gt; 理解成 &lt;code&gt;svn update&lt;/code&gt; 的 Git 版本。这是一个将上游更改同步到本地仓库的快捷方式。下面的图解释了 pull 过程的每一步骤。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xinjg.com1.z0.glb.clouddn.com/git-coll-sync03.svg&quot; alt=&quot;git pull 过程&quot;&gt;&lt;/p&gt;
&lt;p&gt;本来我们以为我们本地的仓库处于已同步状态，但是呢通过 &lt;code&gt;git fetch&lt;/code&gt; 我们发现 origin 上的 master 在我们上次检查之后又有新的提交。于是 &lt;code&gt;git merge&lt;/code&gt; 命令直接将远端 master 上的新内容整合到了本地。&lt;/p&gt;
&lt;h3 id=&quot;拉取和衍合&quot;&gt;拉取和衍合&lt;/h3&gt;&lt;p&gt;&lt;code&gt;--rebase&lt;/code&gt; 参数可以用组织不必要提交的方式来保证线性提交历史。相比较合并，许多开发者更喜欢衍合一些，因为衍合的意思就像：“我想要将我的更改放在其他人的更改之上”。由于这个原因，在 &lt;code&gt;git pull&lt;/code&gt; 时使用 &lt;code&gt;--rebase&lt;/code&gt; 参数比不带衍合参数更像 &lt;code&gt;svn update&lt;/code&gt; 一些。&lt;/p&gt;
&lt;p&gt;实际上，使用 &lt;code&gt;--rebase&lt;/code&gt; 参数拉取实在是太常用了，因此都有一个专用的配置项来配置它：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;label&quot;&gt;git&lt;/span&gt; config --&lt;span class=&quot;preprocessor&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;branch.autosetuprebase &lt;/span&gt;always
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行了上面的命令之后，所有的 &lt;code&gt;git pull&lt;/code&gt; 命令就会自动通过 &lt;code&gt;git rebase&lt;/code&gt; 而非 &lt;code&gt;git merge&lt;/code&gt; 来进行分支整合。&lt;/p&gt;
&lt;h2 id=&quot;示例-2&quot;&gt;示例&lt;/h2&gt;&lt;p&gt;下例展示了如何从中央仓库的 master 分支上同步代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout &lt;span class=&quot;keyword&quot;&gt;master&lt;/span&gt;
&lt;span class=&quot;title&quot;&gt;git&lt;/span&gt; pull --rebase origin
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这就便捷的将我们本地的更改放在了其他人提交的代码的顶部。&lt;/p&gt;
&lt;h1 id=&quot;git_push&quot;&gt;git push&lt;/h1&gt;&lt;p&gt;推送就是我们将本地仓库的提交传送到远端仓库的方法。它是 &lt;code&gt;git fetch&lt;/code&gt; 的反面：获取将提交引入本地分支，推送将提交导出到远端分支。推送本身可能会导致重写提交，因此我们在使用时还是要多加注意。这些内容下面会进行详细的讨论。&lt;/p&gt;
&lt;h2 id=&quot;使用-3&quot;&gt;使用&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;git push &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;remote&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;branch&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该命令表示将特定的分支 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 中的所有必要的提交和内部对象推送到 &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; 上。这一操作给目标仓库创造了一个本地分支。为了防止我们重写提交，当目标仓库处在&lt;strong&gt;非快进合并状态&lt;/strong&gt;&lt;sup&gt;&lt;a href=&quot;#note-1&quot;&gt;注1&lt;/a&gt;&lt;/sup&gt;时，Git 是不允许我们提交的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git push &amp;lt;remote&amp;gt; &lt;span class=&quot;comment&quot;&gt;--force&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;和上面的命令相似，只不过即使没有处在快进合并状态时也可以强制提交。&lt;strong&gt;不要&lt;/strong&gt;使用 &lt;code&gt;--force&lt;/code&gt; 参数，除非你确切的知道自己在干啥。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;keyword&quot;&gt;git&lt;/span&gt; push &amp;lt;remote&amp;gt; --&lt;span class=&quot;literal&quot;&gt;all&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将所有本地分支提交到指定远端上。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git push &amp;lt;remote&amp;gt; &lt;span class=&quot;comment&quot;&gt;--tags&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在使用 &lt;code&gt;--all&lt;/code&gt; 参数时也不会自动把&lt;strong&gt;标签&lt;/strong&gt;&lt;sup&gt;&lt;a href=&quot;#note-2&quot;&gt;注2&lt;/a&gt;&lt;/sup&gt;提交上去的。 &lt;code&gt;--tags&lt;/code&gt; 参数会将我们本地所有的标签提交到远端仓库中。&lt;/p&gt;
&lt;h2 id=&quot;详述-3&quot;&gt;详述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;git push&lt;/code&gt; 命令最常见的使用场景就是将本地的更改推送到中央仓库中。当我们已经积攒了一些本地提交并准备将其与团队中的其他同事分享这些提交时，我们可以先使用交互式的衍合修整我们的提交，然后将它们推送到中央仓库。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xinjg.com1.z0.glb.clouddn.com/git-coll-sync04.svg&quot; alt=&quot;推送提交图解&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图展示了当我们运行 &lt;code&gt;git push origin master&lt;/code&gt; 时本地 &lt;code&gt;master&lt;/code&gt; 分支和中央仓库的 &lt;code&gt;master&lt;/code&gt; 分支之间发生了什么。注意 &lt;code&gt;git push&lt;/code&gt; 命令在本质上与在远端仓库运行 &lt;code&gt;git merge master&lt;/code&gt; 所产生的效果一致。&lt;/p&gt;
&lt;h3 id=&quot;强制推送&quot;&gt;强制推送&lt;/h3&gt;&lt;p&gt;当中央仓库处在非快进合并状态时，Git 会阻止提交以防止我们覆盖中央仓库的历史记录。因此当远端历史与本地历史分离时，我们需要先拉取远端分支将其合并到本地上，然后再尝试推送。这与 SVN 在我们使用 &lt;code&gt;svn update&lt;/code&gt; 提交变更集合之前先让我们与中央仓库同步的做法是一致的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--force&lt;/code&gt; 参数改变了此行为而使远端仓库的分支匹配我们本地的分支，并会删除我们上次提交之后尚有分支的任何更改。我们唯一应该使用强制推送的场景是当我们意识到我们之前推送的提交是有问题的，并使用 &lt;code&gt;git commit --amend&lt;/code&gt; 或交互式衍合来更改了这一提交。然而我们在进行强制推送之前，也必须确认这期间没有同事拉取了我们之前的提交。&lt;/p&gt;
&lt;h3 id=&quot;只推送到裸仓库&quot;&gt;只推送到裸仓库&lt;/h3&gt;&lt;p&gt;再就是我们应该仅往使用 &lt;code&gt;--bare&lt;/code&gt; 参数创建的裸仓库进行推送。由于推送会弄乱远端分支结构，因此千万不要推送到其他开发者的仓库去。但是由于裸仓库没有工作目录，因此并不会扰乱其他人的开发。&lt;/p&gt;
&lt;h2 id=&quot;示例-3&quot;&gt;示例&lt;/h2&gt;&lt;p&gt;下例展示了一种将本地开发推送到中央仓库的一种标准方法。首先，要获取中央仓库的副本并将更改衍合到顶部，以确保我们本地 &lt;code&gt;master&lt;/code&gt; 分支是&lt;strong&gt;最新的（up-to-date）&lt;/strong&gt;。使用交互式衍也是在推送提交前进行清理的一个好选择。之后，使用 &lt;code&gt;git push&lt;/code&gt; 命令将所有本地 &lt;code&gt;master&lt;/code&gt; 分支上的提交推送到中央仓库。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout &lt;span class=&quot;keyword&quot;&gt;master&lt;/span&gt;
&lt;span class=&quot;title&quot;&gt;git&lt;/span&gt; fetch origin &lt;span class=&quot;keyword&quot;&gt;master&lt;/span&gt;
&lt;span class=&quot;title&quot;&gt;git&lt;/span&gt; rebase -i origin/&lt;span class=&quot;keyword&quot;&gt;master&lt;/span&gt;
&lt;span class=&quot;title&quot;&gt;# 进行压缩提交，修改提交信息等工作
git&lt;/span&gt; push origin &lt;span class=&quot;literal&quot;&gt;master&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于我们已经确保本地 &lt;code&gt;master&lt;/code&gt; 分支是最新的，因此推送会导致一个快进合并，使用 &lt;code&gt;git push&lt;/code&gt; 命令也不必抱怨哪些之前提到的非快进合并状态的问题。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;译注&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b id=&quot;note-1&quot;&gt;注1&lt;/b&gt; &lt;strong&gt;非快进合并状态（non-fast-forward merge）&lt;/strong&gt;：与快进状态相对立，按 Git Pro 书上的&lt;a href=&quot;http://iissnan.com/progit/html/zh/ch3_2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;解释&lt;/a&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此非快进合并状态即是指当要合并的分支不是在当前分支的上游，提交出现分岔的状态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b id=&quot;note-2&quot;&gt;注2&lt;/b&gt; &lt;strong&gt;标签&lt;/strong&gt;：再发布版本的时候打上标签标记，是 VCS 的通用方法。详见 Git Pro &lt;a href=&quot;http://iissnan.com/progit/html/zh/ch2_6.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;打标签&lt;/a&gt;一章。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xinjg.com1.z0.glb.clouddn.com/git-coll-synchero.svg&quot; alt=&quot;同步&quot;&gt;&lt;/p&gt;
&lt;p&gt;SVN 使用一个单独的中心仓库以作为开发者的通信枢纽，其协作的方式是开发者的工作副本与中央仓库互相发送变更记录。这与 Git 的协作模式有所不同，Git 中每个开发者都拥有仓库的副本，以及完整的本地历史和分支结构。用户通常只需要提供一系列的提交而不是单个的变更记录。Git 允许我们在仓库之间共享整个分支，而不是单单的从工作副本提交一个变更记录到中央仓库去。&lt;/p&gt;
&lt;p&gt;下面介绍的命令可以帮助我们管理与其他仓库的连接：我们可以使用“推送”分支的方式将本地历史发布到其他仓库，也可以使用“拉取”分支的方式将别人贡献的代码获取到本地。&lt;/p&gt;
    
    </summary>
    
      <category term="Git魔导之路" scheme="http://malcolmyu.github.io/malnote/categories/Git%E9%AD%94%E5%AF%BC%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Git" scheme="http://malcolmyu.github.io/malnote/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Promise A+ 规范</title>
    <link href="http://malcolmyu.github.io/malnote/2015/06/12/Promises-A-Plus/"/>
    <id>http://malcolmyu.github.io/malnote/2015/06/12/Promises-A-Plus/</id>
    <published>2015-06-11T16:00:00.000Z</published>
    <updated>2016-05-08T08:43:01.000Z</updated>
    
    <content type="html">&lt;p&gt;英文原文：&lt;a href=&quot;https://promisesaplus.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Promise/A+&lt;/a&gt;&lt;br&gt;图灵译文：&lt;a href=&quot;http://www.ituring.com.cn/article/66566&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;【翻译】Promises/A+规范&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;译者序：&lt;/strong&gt;一年前曾译过 Promise/A+ 规范，适时完全不懂 Promise 的思想，纯粹将翻译的过程当作学习，旧文译下来诘屈聱牙，读起来十分不顺畅。谁知这样一篇拙译，一年之间竟然点击数千，成为谷歌搜索的头条。今日在理解之后重译此规范，以飨读者。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;一个开放、健全且通用的 JavaScript Promise 标准。由开发者制定，供开发者参考。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;译文术语&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;解决（fulfill）&lt;/strong&gt;：指一个 promise 成功时进行的一系列操作，如状态的改变、回调的执行。虽然规范中用 &lt;code&gt;fulfill&lt;/code&gt; 来表示解决，但在后世的 promise 实现多以 &lt;code&gt;resolve&lt;/code&gt; 来指代之。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拒绝（reject）&lt;/strong&gt;：指一个 promise 失败时进行的一系列操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;终值（eventual value）&lt;/strong&gt;：所谓终值，指的是 promise 被&lt;strong&gt;解决&lt;/strong&gt;时传递给解决回调的值，由于 promise 有&lt;strong&gt;一次性&lt;/strong&gt;的特征，因此当这个值被传递时，标志着 promise 等待态的结束，故称之终值，有时也直接简称为值（value）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;据因（reason）&lt;/strong&gt;：也就是拒绝原因，指在 promise 被&lt;strong&gt;拒绝&lt;/strong&gt;时传递给拒绝回调的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;Promise 表示一个异步操作的最终结果，与之进行交互的方式主要是 &lt;code&gt;then&lt;/code&gt; 方法，该方法注册了两个回调函数，用于接收 promise 的终值或本 promise 不能执行的原因。&lt;/p&gt;
&lt;p&gt;本规范详细列出了 &lt;code&gt;then&lt;/code&gt; 方法的执行过程，所有遵循 Promises/A+ 规范实现的 promise 均可以本标准作为参照基础来实施 &lt;code&gt;then&lt;/code&gt; 方法。因而本规范是十分稳定的。尽管 Promise/A+ 组织有时可能会修订本规范，但主要是为了处理一些特殊的边界情况，且这些改动都是微小且向下兼容的。如果我们要进行大规模不兼容的更新，我们一定会在事先进行谨慎地考虑、详尽的探讨和严格的测试。&lt;/p&gt;
&lt;p&gt;从历史上说，本规范实际上是把之前 &lt;a href=&quot;http://wiki.commonjs.org/wiki/Promises/A&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Promise/A 规范&lt;/a&gt; 中的建议明确成为了行为标准：我们一方面扩展了原有规范约定俗成的行为，一方面删减了原规范的一些特例情况和有问题的部分。&lt;/p&gt;
&lt;p&gt;最后，核心的 Promises/A+ 规范不设计如何创建、解决和拒绝 promise，而是专注于提供一个通用的 &lt;code&gt;then&lt;/code&gt; 方法。上述对于 promises 的操作方法将来在其他规范中可能会提及。&lt;/p&gt;
&lt;h1 id=&quot;术语&quot;&gt;术语&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;Promise&quot;&gt;Promise&lt;/h2&gt;&lt;p&gt;promise 是一个拥有 &lt;code&gt;then&lt;/code&gt; 方法的对象或函数，其行为符合本规范；&lt;/p&gt;
&lt;h2 id=&quot;thenable&quot;&gt;thenable&lt;/h2&gt;&lt;p&gt;是一个定义了 &lt;code&gt;then&lt;/code&gt; 方法的对象或函数，文中译作“拥有 &lt;code&gt;then&lt;/code&gt; 方法”；&lt;/p&gt;
&lt;h2 id=&quot;值（value）&quot;&gt;值（value）&lt;/h2&gt;&lt;p&gt;指任何 JavaScript 的合法值（包括 &lt;code&gt;undefined&lt;/code&gt; , thenable 和 promise）；&lt;/p&gt;
&lt;h2 id=&quot;异常（exception）&quot;&gt;异常（exception）&lt;/h2&gt;&lt;p&gt;是使用 &lt;code&gt;throw&lt;/code&gt; 语句抛出的一个值。&lt;/p&gt;
&lt;h2 id=&quot;据因（reason）&quot;&gt;据因（reason）&lt;/h2&gt;&lt;p&gt;表示一个 promise 的拒绝原因。&lt;/p&gt;
&lt;h1 id=&quot;要求&quot;&gt;要求&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;Promise_的状态&quot;&gt;Promise 的状态&lt;/h2&gt;&lt;p&gt;一个 Promise 的当前状态必须为以下三种状态中的一种：&lt;strong&gt;等待态（Pending）&lt;/strong&gt;、&lt;strong&gt;执行态（Fulfilled）&lt;/strong&gt;和&lt;strong&gt;拒绝态（Rejected）&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;等待态（Pending）&quot;&gt;等待态（Pending）&lt;/h3&gt;&lt;p&gt;处于等待态时，promise 需满足以下条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以迁移至执行态或拒绝态&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;执行态（Fulfilled）&quot;&gt;执行态（Fulfilled）&lt;/h3&gt;&lt;p&gt;处于执行态时，promise 需满足以下条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不能迁移至其他任何状态&lt;/li&gt;
&lt;li&gt;必须拥有一个&lt;strong&gt;不可变&lt;/strong&gt;的终值&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;拒绝态（Rejected）&quot;&gt;拒绝态（Rejected）&lt;/h3&gt;&lt;p&gt;处于拒绝态时，promise 需满足以下条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不能迁移至其他任何状态&lt;/li&gt;
&lt;li&gt;必须拥有一个&lt;strong&gt;不可变&lt;/strong&gt;的据因&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里的不可变指的是恒等（即可用 &lt;code&gt;===&lt;/code&gt; 判断相等），而不是意味着更深层次的不可变（&lt;strong&gt;译者注：&lt;/strong&gt; 盖指当 value 或 reason 不是基本值时，只要求其引用地址相等，但属性值可被更改）。&lt;/p&gt;
&lt;h2 id=&quot;Then_方法&quot;&gt;&lt;strong&gt;Then 方法&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;一个 promise 必须提供一个 &lt;code&gt;then&lt;/code&gt; 方法以访问其当前值、终值和据因。&lt;/p&gt;
&lt;p&gt;promise 的 &lt;code&gt;then&lt;/code&gt; 方法接受两个参数：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;promise.then(onFulfilled, onRejected)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;参数可选&quot;&gt;参数可选&lt;/h3&gt;&lt;p&gt;&lt;code&gt;onFulfilled&lt;/code&gt; 和 &lt;code&gt;onRejected&lt;/code&gt; 都是可选参数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 &lt;code&gt;onFulfilled&lt;/code&gt; 不是函数，其必须被忽略&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;onRejected&lt;/code&gt; 不是函数，其必须被忽略&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;onFulfilled_特性&quot;&gt;&lt;code&gt;onFulfilled&lt;/code&gt; 特性&lt;/h3&gt;&lt;p&gt;如果 &lt;code&gt;onFulfilled&lt;/code&gt; 是函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;code&gt;promise&lt;/code&gt; 执行结束后其必须被调用，其第一个参数为 &lt;code&gt;promise&lt;/code&gt; 的终值&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;promise&lt;/code&gt; 执行结束前其不可被调用&lt;/li&gt;
&lt;li&gt;其调用次数不可超过一次&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;onRejected_特性&quot;&gt;&lt;code&gt;onRejected&lt;/code&gt; 特性&lt;/h3&gt;&lt;p&gt;如果 &lt;code&gt;onRejected&lt;/code&gt; 是函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;code&gt;promise&lt;/code&gt; 被拒绝执行后其必须被调用，其第一个参数为 &lt;code&gt;promise&lt;/code&gt; 的据因&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;promise&lt;/code&gt; 被拒绝执行前其不可被调用&lt;/li&gt;
&lt;li&gt;其调用次数不可超过一次&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;调用时机&quot;&gt;调用时机&lt;/h3&gt;&lt;p&gt;&lt;code&gt;onFulfilled&lt;/code&gt; 和 &lt;code&gt;onRejected&lt;/code&gt; 只有在&lt;a href=&quot;http://es5.github.io/#x10.3&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;执行环境&lt;/a&gt;堆栈仅包含&lt;strong&gt;平台代码&lt;/strong&gt;时才可被调用&lt;a href=&quot;#note-1&quot;&gt;注1&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;调用要求&quot;&gt;调用要求&lt;/h3&gt;&lt;p&gt;&lt;code&gt;onFulfilled&lt;/code&gt; 和 &lt;code&gt;onRejected&lt;/code&gt; 必须被作为函数调用（即没有 &lt;code&gt;this&lt;/code&gt; 值）&lt;sup&gt;&lt;a href=&quot;#note-2&quot;&gt;注2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h3 id=&quot;多次调用&quot;&gt;多次调用&lt;/h3&gt;&lt;p&gt;&lt;code&gt;then&lt;/code&gt; 方法可以被同一个 &lt;code&gt;promise&lt;/code&gt; 调用多次&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;code&gt;promise&lt;/code&gt; 成功执行时，所有 &lt;code&gt;onFulfilled&lt;/code&gt; 需按照其注册顺序依次回调&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;promise&lt;/code&gt; 被拒绝执行时，所有的 &lt;code&gt;onRejected&lt;/code&gt; 需按照其注册顺序依次回调&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;返回&quot;&gt;返回&lt;/h3&gt;&lt;p&gt;&lt;code&gt;then&lt;/code&gt; 方法必须返回一个 &lt;code&gt;promise&lt;/code&gt; 对象 &lt;sup&gt;&lt;a href=&quot;#note-3&quot;&gt;注3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;promise2 = promise1.then(onFulfilled, onRejected);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;如果 &lt;code&gt;onFulfilled&lt;/code&gt; 或者 &lt;code&gt;onRejected&lt;/code&gt; 返回一个值 &lt;code&gt;x&lt;/code&gt; ，则运行下面的 &lt;strong&gt;Promise 解决过程&lt;/strong&gt;：&lt;code&gt;[[Resolve]](promise2, x)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;onFulfilled&lt;/code&gt; 或者 &lt;code&gt;onRejected&lt;/code&gt; 抛出一个异常 &lt;code&gt;e&lt;/code&gt; ，则 &lt;code&gt;promise2&lt;/code&gt; 必须拒绝执行，并返回拒因 &lt;code&gt;e&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;onFulfilled&lt;/code&gt; 不是函数且 &lt;code&gt;promise1&lt;/code&gt; 成功执行， &lt;code&gt;promise2&lt;/code&gt; 必须成功执行并返回相同的值&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;onRejected&lt;/code&gt; 不是函数且 &lt;code&gt;promise1&lt;/code&gt; 拒绝执行， &lt;code&gt;promise2&lt;/code&gt; 必须拒绝执行并返回相同的据因&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;译者注：&lt;/strong&gt; 理解上面的“返回”部分非常重要，即：&lt;strong&gt;不论 &lt;code&gt;promise1&lt;/code&gt; 被 reject 还是被 resolve 时 &lt;code&gt;promise2&lt;/code&gt; 都会被 resolve，只有出现异常时才会被 rejected&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;Promise_解决过程&quot;&gt;&lt;strong&gt;Promise 解决过程&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Promise 解决过程&lt;/strong&gt; 是一个抽象的操作，其需输入一个 &lt;code&gt;promise&lt;/code&gt; 和一个值，我们表示为 &lt;code&gt;[[Resolve]](promise, x)&lt;/code&gt;，如果 &lt;code&gt;x&lt;/code&gt; 有 &lt;code&gt;then&lt;/code&gt; 方法且看上去像一个 Promise ，解决程序即尝试使 &lt;code&gt;promise&lt;/code&gt; 接受 &lt;code&gt;x&lt;/code&gt; 的状态；否则其用 &lt;code&gt;x&lt;/code&gt; 的值来执行 &lt;code&gt;promise&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;这种 &lt;em&gt;thenable&lt;/em&gt; 的特性使得 Promise 的实现更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 &lt;code&gt;then&lt;/code&gt; 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与那些不太规范但可用的实现能良好共存。&lt;/p&gt;
&lt;p&gt;运行 &lt;code&gt;[[Resolve]](promise, x)&lt;/code&gt; 需遵循以下步骤：&lt;/p&gt;
&lt;h3 id=&quot;x_与_promise_相等&quot;&gt;&lt;code&gt;x&lt;/code&gt; 与 &lt;code&gt;promise&lt;/code&gt; 相等&lt;/h3&gt;&lt;p&gt;如果 &lt;code&gt;promise&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 指向同一对象，以 &lt;code&gt;TypeError&lt;/code&gt; 为据因拒绝执行 &lt;code&gt;promise&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;x_为_Promise&quot;&gt;&lt;code&gt;x&lt;/code&gt; 为 Promise&lt;/h3&gt;&lt;p&gt;如果 &lt;code&gt;x&lt;/code&gt; 为 Promise ，则使 &lt;code&gt;promise&lt;/code&gt; 接受 &lt;code&gt;x&lt;/code&gt; 的状态 &lt;sup&gt;&lt;a href=&quot;#note-4&quot;&gt;注4&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 &lt;code&gt;x&lt;/code&gt; 处于等待态， &lt;code&gt;promise&lt;/code&gt; 需保持为等待态直至 &lt;code&gt;x&lt;/code&gt; 被执行或拒绝&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;x&lt;/code&gt; 处于执行态，用相同的值执行 &lt;code&gt;promise&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;x&lt;/code&gt; 处于拒绝态，用相同的据因拒绝 &lt;code&gt;promise&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;x_为对象或函数&quot;&gt;&lt;code&gt;x&lt;/code&gt; 为对象或函数&lt;/h3&gt;&lt;p&gt;如果 &lt;code&gt;x&lt;/code&gt; 为对象或者函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把 &lt;code&gt;x.then&lt;/code&gt; 赋值给 &lt;code&gt;then&lt;/code&gt; &lt;sup&gt;&lt;a href=&quot;#note-5&quot;&gt;注5&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;如果取 &lt;code&gt;x.then&lt;/code&gt; 的值时抛出错误 &lt;code&gt;e&lt;/code&gt; ，则以 &lt;code&gt;e&lt;/code&gt; 为据因拒绝 &lt;code&gt;promise&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;then&lt;/code&gt; 是函数，将 &lt;code&gt;x&lt;/code&gt; 作为函数的作用域 &lt;code&gt;this&lt;/code&gt; 调用之。传递两个回调函数作为参数，第一个参数叫做 &lt;code&gt;resolvePromise&lt;/code&gt; ，第二个参数叫做 &lt;code&gt;rejectPromise&lt;/code&gt;:&lt;ul&gt;
&lt;li&gt;如果 &lt;code&gt;resolvePromise&lt;/code&gt; 以值 &lt;code&gt;y&lt;/code&gt; 为参数被调用，则运行 &lt;code&gt;[[Resolve]](promise, y)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;rejectPromise&lt;/code&gt; 以据因 &lt;code&gt;r&lt;/code&gt; 为参数被调用，则以据因 &lt;code&gt;r&lt;/code&gt; 拒绝 &lt;code&gt;promise&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;resolvePromise&lt;/code&gt; 和 &lt;code&gt;rejectPromise&lt;/code&gt; 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用&lt;/li&gt;
&lt;li&gt;如果调用 &lt;code&gt;then&lt;/code&gt; 方法抛出了异常 &lt;code&gt;e&lt;/code&gt;：&lt;ul&gt;
&lt;li&gt;如果 &lt;code&gt;resolvePromise&lt;/code&gt; 或 &lt;code&gt;rejectPromise&lt;/code&gt; 已经被调用，则忽略之&lt;/li&gt;
&lt;li&gt;否则以 &lt;code&gt;e&lt;/code&gt; 为据因拒绝 &lt;code&gt;promise&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;then&lt;/code&gt; 不是函数，以 &lt;code&gt;x&lt;/code&gt; 为参数执行 &lt;code&gt;promise&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;x&lt;/code&gt; 不为对象或者函数，以 &lt;code&gt;x&lt;/code&gt; 为参数执行 &lt;code&gt;promise&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果一个 promise 被一个循环的 &lt;em&gt;thenable&lt;/em&gt; 链中的对象解决，而 &lt;code&gt;[[Resolve]](promise, thenable)&lt;/code&gt; 的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励施者检测这样的递归是否存在，若检测到存在则以一个可识别的 &lt;code&gt;TypeError&lt;/code&gt; 为据因来拒绝 &lt;code&gt;promise&lt;/code&gt; &lt;sup&gt;&lt;a href=&quot;#note-6&quot;&gt;注6&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;h1 id=&quot;注释&quot;&gt;注释&lt;/h1&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;b id=&quot;note-1&quot;&gt;注1&lt;/b&gt; 这里的&lt;strong&gt;平台代码&lt;/strong&gt;指的是引擎、环境以及 promise 的实施代码。实践中要确保 &lt;code&gt;onFulfilled&lt;/code&gt; 和 &lt;code&gt;onRejected&lt;/code&gt; 方法异步执行，且应该在 &lt;code&gt;then&lt;/code&gt; 方法被调用的那一轮事件循环之后的新执行栈中执行。这个事件队列可以采用“宏任务（macro-task）”机制或者“微任务（micro-task）”机制来实现。由于 promise 的实施代码本身就是平台代码（&lt;strong&gt;译者注：&lt;/strong&gt; 即都是 JavaScript），故代码自身在处理在处理程序时可能已经包含一个任务调度队列或&lt;a href=&quot;https://en.wikipedia.org/wiki/Trampoline_(computing&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;『跳板』&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;译者注：&lt;/strong&gt; 这里提及了 macrotask 和 microtask 两个概念，这表示异步任务的两种分类。在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 macrotask 的队列（这个队列也被叫做 task queue）中取出第一个任务，执行完毕后取出 microtask 队列中的所有任务顺序执行；之后再取 macrotask 任务，周而复始，直至两个队列的任务都取完。&lt;/p&gt;
&lt;p&gt;  两个类别的具体分类如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;macro-task:&lt;/strong&gt; script（整体代码）, &lt;code&gt;setTimeout&lt;/code&gt;, &lt;code&gt;setInterval&lt;/code&gt;, &lt;code&gt;setImmediate&lt;/code&gt;, I/O, UI rendering&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;micro-task:&lt;/strong&gt; &lt;code&gt;process.nextTick&lt;/code&gt;, &lt;code&gt;Promises&lt;/code&gt;（这里指浏览器实现的原生 Promise）, &lt;code&gt;Object.observe&lt;/code&gt;, &lt;code&gt;MutationObserver&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;详见 &lt;a href=&quot;http://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event-loop-context&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stackoverflow 解答&lt;/a&gt; 或 &lt;a href=&quot;http://wengeezhang.com/?p=11&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;b id=&quot;note-2&quot;&gt;注2&lt;/b&gt; 也就是说在 &lt;strong&gt;严格模式（strict）&lt;/strong&gt; 中，函数 &lt;code&gt;this&lt;/code&gt; 的值为 &lt;code&gt;undefined&lt;/code&gt; ；在非严格模式中其为全局对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;b id=&quot;note-3&quot;&gt;注3&lt;/b&gt; 代码实现在满足所有要求的情况下可以允许 &lt;code&gt;promise2 === promise1&lt;/code&gt; 。每个实现都要文档说明其是否允许以及在何种条件下允许 &lt;code&gt;promise2 === promise1&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;b id=&quot;note-4&quot;&gt;注4&lt;/b&gt; 总体来说，如果 &lt;code&gt;x&lt;/code&gt; 符合当前实现，我们才认为它是真正的 &lt;em&gt;promise&lt;/em&gt; 。这一规则允许那些特例实现接受符合已知要求的 Promises 状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;b id=&quot;note-5&quot;&gt;注5&lt;/b&gt; 这步我们先是存储了一个指向 &lt;code&gt;x.then&lt;/code&gt; 的引用，然后测试并调用该引用，以避免多次访问 &lt;code&gt;x.then&lt;/code&gt; 属性。这种预防措施确保了该属性的一致性，因为其值可能在检索调用时被改变。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;b id=&quot;note-6&quot;&gt;注6&lt;/b&gt; 实现不应该对 &lt;em&gt;thenable&lt;/em&gt; 链的深度设限，并假定超出本限制的递归就是无限循环。只有真正的循环递归才应能导致 &lt;code&gt;TypeError&lt;/code&gt; 异常；如果一条无限长的链上 &lt;em&gt;thenable&lt;/em&gt; 均不相同，那么递归下去永远是正确的行为。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;英文原文：&lt;a href=&quot;https://promisesaplus.com/&quot;&gt;Promise/A+&lt;/a&gt;&lt;br&gt;图灵译文：&lt;a href=&quot;http://www.ituring.com.cn/article/66566&quot;&gt;【翻译】Promises/A+规范&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;译者序：&lt;/strong&gt;一年前曾译过 Promise/A+ 规范，适时完全不懂 Promise 的思想，纯粹将翻译的过程当作学习，旧文译下来诘屈聱牙，读起来十分不顺畅。谁知这样一篇拙译，一年之间竟然点击数千，成为谷歌搜索的头条。今日在理解之后重译此规范，以飨读者。&lt;/p&gt;
    
    </summary>
    
      <category term="技术研究" scheme="http://malcolmyu.github.io/malnote/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Javascript" scheme="http://malcolmyu.github.io/malnote/tags/Javascript/"/>
    
      <category term="Promise" scheme="http://malcolmyu.github.io/malnote/tags/Promise/"/>
    
      <category term="翻译" scheme="http://malcolmyu.github.io/malnote/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>JSDoc 配置使用概览</title>
    <link href="http://malcolmyu.github.io/malnote/2015/04/25/Introduction-of-Jsdoc/"/>
    <id>http://malcolmyu.github.io/malnote/2015/04/25/Introduction-of-Jsdoc/</id>
    <published>2015-04-24T16:00:00.000Z</published>
    <updated>2015-11-27T07:31:43.000Z</updated>
    
    <content type="html">&lt;p&gt;尽管一个好的项目文档能让项目增光添彩，但文档的作用始终是锦上添花而非雪中送炭，对于开发者来说，费尽心神的整理项目文档似乎也并非是一件令人愉快的事情。在使用题中所述的工具——jsdoc和编写本文的同时，笔者也是几度懊恼：这东西在项目中真的有用吗？是不是有点浪费时间？但随着项目体量的增大和开发人员的增多，使用并自动化维护一份好的文档所带来的优势也是逐渐显现。笔者也决心写一篇科普小文，说一说文档工具的使用注意要点。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;JSDoc_命令行使用方法&quot;&gt;JSDoc 命令行使用方法&lt;/h1&gt;&lt;p&gt;通过命令行来生成 JSDoc 有两种适合前端的方式：一种是通过 npm 来安装 jsdoc 来生成文档，需要学习相关的命令行参数与配置文件的编写；另一种是使用 grunt 来生成 jsdoc，这种方法配置起来比较简单，等于将各种配置参数写在了 Gruntfile.js 的配置项里，然后可以自定义各种操作命令，十分灵活。下面就分别就这两种方法介绍一下。&lt;/p&gt;
&lt;h2 id=&quot;通过_npm_生成&quot;&gt;通过 npm 生成&lt;/h2&gt;&lt;p&gt;通过 npm 的生成方式主要包含安装、配置和生成三步。安装的方式如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install jsdoc -g&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;  
&lt;p&gt;然后去指定文件（如 &lt;code&gt;test.js&lt;/code&gt;）的路径下运行&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;jsdoc test.js&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;      
&lt;p&gt;文档即可被生成在根目录下的 out 文件夹中。&lt;/p&gt;
&lt;p&gt;上面的过程看上去十分简便，但我们省略了配置这一步，如果我们不想生成在 out 文件夹下怎么办？我们想针对一个项目工程生成文档怎么办？觉得原有文档模板太丑想换个风格怎么办（&lt;em&gt;说句实话个人感觉默认模板是目前见过所有模板中最好看的……&lt;/em&gt;）？这就需要在配置这一步中进行繁杂的个性化指定。对于项目的个性化指定可以通过&lt;strong&gt;配置文件&lt;/strong&gt;和&lt;strong&gt;命令行参数&lt;/strong&gt;两种方式来设置，先说一下命令行参数的配置。&lt;/p&gt;
&lt;p&gt;有关命令行参数的配置可以参考&lt;a href=&quot;http://usejsdoc.org/about-commandline.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网文档&lt;/a&gt;的详细说明，这里只列出几个重要的参数：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;参数&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;全称&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;--configure&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;引入配置项，默认为 jsdoc 安装目录的 &lt;code&gt;config.json&lt;/code&gt; 文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;-d&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;--destination&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;配置文档输出的目录，默认为 &lt;code&gt;./out&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;-P&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;--package&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;可以将 &lt;code&gt;package.json&lt;/code&gt; 文件写入文档中，默认写入当前路径的第一个 &lt;code&gt;package.json&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;-r&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;--recurse&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;递归调用路径的子目录查找 js 文件，当生成一个文件夹下的全部 js 的文档时必须使用这个参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;-R&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;--readme&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;可以引入一个说明文件，默认将当前路径中的第一个 &lt;code&gt;readme.md&lt;/code&gt; 文件添加到文档中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;-t&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;--template&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;可以给文档指定一个第三方的模板&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;举个例子，比如我们要将 &lt;code&gt;./src&lt;/code&gt; 路径下的所有 js 文件生成文档，然后存放在 &lt;code&gt;./docs&lt;/code&gt; 文件夹中，操作如下：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;jsdoc src -r &lt;span class=&quot;operator&quot;&gt;-d&lt;/span&gt; docs&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;  
&lt;p&gt;但是这样感觉还是不方便，如何对特定文件进行文档解析呢？如果有一些文件不想进行文档解析如何从中间剔除呢？而且每次都要输入如此复杂的命令行参数也十分不方便。要解决这些问题，就需要用到配置文件 &lt;code&gt;conf.json&lt;/code&gt; 了。&lt;/p&gt;
&lt;p&gt;对于配置文件的详细解释可以参见&lt;a href=&quot;http://usejsdoc.org/about-configuring-jsdoc.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;的说明，这里也是举一个简单的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &quot;&lt;span class=&quot;attribute&quot;&gt;tags&lt;/span&gt;&quot;: &lt;span class=&quot;value&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &quot;&lt;span class=&quot;attribute&quot;&gt;allowUnknownTags&lt;/span&gt;&quot;: &lt;span class=&quot;value&quot;&gt;&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&amp;#125;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &quot;&lt;span class=&quot;attribute&quot;&gt;source&lt;/span&gt;&quot;: &lt;span class=&quot;value&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &quot;&lt;span class=&quot;attribute&quot;&gt;include&lt;/span&gt;&quot;: &lt;span class=&quot;value&quot;&gt;[&lt;span class=&quot;string&quot;&gt;&quot;./src/lib&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;./src/util&quot;&lt;/span&gt;]&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &quot;&lt;span class=&quot;attribute&quot;&gt;exclude&lt;/span&gt;&quot;: &lt;span class=&quot;value&quot;&gt;[&lt;span class=&quot;string&quot;&gt;&quot;./src/lib/demo&quot;&lt;/span&gt;]&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &quot;&lt;span class=&quot;attribute&quot;&gt;includePattern&lt;/span&gt;&quot;: &lt;span class=&quot;value&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;.+\\.js$&quot;&lt;/span&gt;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &quot;&lt;span class=&quot;attribute&quot;&gt;excludePattern&lt;/span&gt;&quot;: &lt;span class=&quot;value&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;(^|\\/|\\\\)_&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&amp;#125;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &quot;&lt;span class=&quot;attribute&quot;&gt;opts&lt;/span&gt;&quot;: &lt;span class=&quot;value&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &quot;&lt;span class=&quot;attribute&quot;&gt;recurse&lt;/span&gt;&quot;: &lt;span class=&quot;value&quot;&gt;&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tags.allowUnknownTags&lt;/code&gt; 表示允许使用为定义的 tag 标签，不然使用未知标签会报错；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;source.include&lt;/code&gt; 表示需要进行文档解析的文件（夹）路径；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;source.exclude&lt;/code&gt; 表示不需要解析的文件（夹）路径；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;source.includePattern&lt;/code&gt; 表示要进行文档解析的文件类型，支持正则进行文件名匹配，上文表示只能解析 *.js 文件；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;source.excludePattern&lt;/code&gt; 表示不要进行解析的文件类型，上文表示所有以下划线开头的文件和文件夹都不被解析；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;opts.recurse&lt;/code&gt; 表示是否递归解析文件夹，上文表示继续拧递归解析，即使用 &lt;code&gt;-r&lt;/code&gt; 参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里的 &lt;code&gt;opts&lt;/code&gt; 里面的内容与上表中命令行参数配置的内容一致，即也可以在此处配置各种参数，详情官网文档中有叙述。将上文保存为一个 json 格式的文件，然后使用 &lt;code&gt;-c&lt;/code&gt; 参数引入，就可以按照设定好的规则直接批量生成文档了。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;jsdoc -c conf.json&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;通过_grunt_生成&quot;&gt;通过 grunt 生成&lt;/h2&gt;&lt;p&gt;在项目中如果使用了 grunt 工具，也可以将 jsdoc 集成到 grunt 中去。这种方式十分的简便，在其 &lt;a href=&quot;https://github.com/krampstudio/grunt-jsdoc&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github 地址&lt;/a&gt;上也有详尽的介绍，具体流程与其他的 grunt 模块差别不大，使用如下命令进行安装：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install grunt-jsdoc --save-dev&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后在 &lt;code&gt;Gruntfile.js&lt;/code&gt; 文件中进行配置，就可以在命令行中使用了：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;grunt.initConfig(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    jsdoc: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dist: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 必填项，需要生成文档的路径数组，也可以将 README.md 文件加入其中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            src: [&lt;span class=&quot;string&quot;&gt;&#39;src/*.js&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;test/*.js&#39;&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 可选项，jsdoc bin 文件路径，一般不写，会自己在 node_modules 中寻找&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            jsdoc: &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            options: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// 必填项，生成文件的路径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                destination: &lt;span class=&quot;string&quot;&gt;&#39;./docs/&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// 可选项，conf 文件的路径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                configure: &lt;span class=&quot;string&quot;&gt;&#39;conf.json&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// 可选项，模板路径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                template: &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;grunt.task.loadNpmTasks(&lt;span class=&quot;string&quot;&gt;&#39;grunt-jsdoc&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;grunt.task.registerTask(&lt;span class=&quot;string&quot;&gt;&#39;doc&#39;&lt;/span&gt;, [&lt;span class=&quot;string&quot;&gt;&#39;jsdoc&#39;&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;grunt doc&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要注意的是，配置项中的 &lt;code&gt;options&lt;/code&gt; 内容与 &lt;code&gt;conf.json&lt;/code&gt; 中 &lt;code&gt;opts&lt;/code&gt; 的内容也一致。&lt;/p&gt;
&lt;h1 id=&quot;JSDoc_注释规范&quot;&gt;JSDoc 注释规范&lt;/h1&gt;&lt;p&gt;上面的一堆其实都是虚的，最主要的还是在代码中按照 JSDoc 要求的注释规范详尽的写清楚注释。JSDoc 的注释有一条很重要的规范就是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; It must start with a &lt;code&gt;/**&lt;/code&gt; sequence in order to be recognized by the JSDoc parser. Comments beginning with &lt;code&gt;/*&lt;/code&gt;, &lt;code&gt;/***&lt;/code&gt;, or more than 3 stars will be ignored. This is a feature to allow you to suppress parsing of comment blocks.&lt;/p&gt;
&lt;p&gt;必须以 &lt;code&gt;/**&lt;/code&gt; 开头才能被 JSDoc 的解析器识别。 以 &lt;code&gt;/*&lt;/code&gt;、&lt;code&gt;/***&lt;/code&gt;、 或者超过三个 &lt;code&gt;*&lt;/code&gt; 开头的注释我们都不管。这可是我们做的一个 feature 哟~它可以帮助你避免解析你不想解析的注释。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用 &lt;code&gt;/**&lt;/code&gt; 开始注释之后，就需要研究一下注释的标签（Tags），JSDoc 提供了几十种标签，满足我们各种稀奇古怪的需求。我们先从单个文件的注释说起，对 JSDoc 的注释规范进行说明。&lt;/p&gt;
&lt;h2 id=&quot;单个文件注释&quot;&gt;单个文件注释&lt;/h2&gt;&lt;p&gt;提到单个文件注释，首先要说到 JSDoc 里面的一个概念，换做&lt;strong&gt;块级标签（Block Tag）&lt;/strong&gt;与&lt;strong&gt;行内标签（Block Tag）&lt;/strong&gt;，整的这么玄乎，无非就是说有些标签是用 &lt;code&gt;@&lt;/code&gt; 打头起一行，叫做块级；有些标签是用 &lt;code&gt;{}&lt;/code&gt; 包裹放在行内，最常见的就是 &lt;code&gt;@type&lt;/code&gt; 和 &lt;code&gt;@link&lt;/code&gt; 标签，可以放在行内对变量进行类型说明与解释。如：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 大哥大嫂过年好&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @param &amp;#123;string&amp;#125; parent - 你是我的爷&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @param &amp;#123;string&amp;#125; child - 我是你的儿&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;happyNewYear&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;parent, child&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以下是单文件注释中常用的标签：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;标签&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;@alias&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;同名引用，用于指定一个同名属性或在非显示的情况下标明从属关系，详见下节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;@author&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;说明这篇代码谁写的，&lt;del&gt;方便出 bug 的时候削人&lt;/del&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;@class&lt;/code&gt; &lt;code&gt;@constructor&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;标记一个函数为构造函数，可以使用 &lt;code&gt;new&lt;/code&gt; 来实例化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;@constant&lt;/code&gt; &lt;code&gt;@const&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;将一个变量标记为常量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;@description&lt;/code&gt; &lt;code&gt;@desc&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;进行描述，一般会把注释开头的文字默认作为描述&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;@enum&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;标注一个对象为枚举对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;@example&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;可以给文档提供一个如何使用的例子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;@file&lt;/code&gt; &lt;code&gt;@fileoverview&lt;/code&gt; &lt;code&gt;@overview&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;表示对一个文件的描述&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;@global&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;标记一个全局变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;@param&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;标记一个函数的参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;@returns&lt;/code&gt; &lt;code&gt;@return&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;标记一个函数的返回值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;@this&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;标注一个 &lt;code&gt;this&lt;/code&gt; 关键字的指向&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;但是在项目中，我们可能拥有一堆又一堆的单个文件都需要添加注释，总不能把这些方法啊变量啊的注释都丢到一个文档页面中吧。不用担心，JSDoc 提供了一种模块化注释的方式帮我们解决这一问题。&lt;/p&gt;
&lt;h2 id=&quot;模块化注释&quot;&gt;模块化注释&lt;/h2&gt;&lt;p&gt;JSDoc 中对模块的表示共有三种方法，分别为&lt;strong&gt;类（&lt;code&gt;@class&lt;/code&gt;）&lt;/strong&gt;、&lt;strong&gt;模块（&lt;code&gt;@module&lt;/code&gt;）&lt;/strong&gt;和&lt;strong&gt;命名空间（&lt;code&gt;@namespace&lt;/code&gt;）&lt;/strong&gt;。使用上面三个标签进行标注的话，其从属的属性都可以使用长名进行引用。&lt;code&gt;@module&lt;/code&gt; 顾名思义是用来标注一个 JS 模块的，一般用这个模块再被 &lt;code&gt;require&lt;/code&gt; 的时候的写法作为名字标注。比如这样一个模块：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 表单校验模块&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @module lib/validator&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** 校验通过方法 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;exports.valid = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** 校验失败方法 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;exports.inValid = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 另一个文件在使用时需要这样用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;lib/validator&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;正如上文所写，对于一个模块需要 &lt;code&gt;exports&lt;/code&gt; 的方法可以直接写双星注释，会被 JSDoc 所自动识别。但有些情况下为了我们可能会先给一个本地对象挂一堆方法然后把这个对象直接 &lt;code&gt;exports&lt;/code&gt;。为了标明它们的从属关系，我们就可以用到 &lt;code&gt;@alias&lt;/code&gt; 别名标签。如下例：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 表单校验模块&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @module lib/validator&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @alias module:lib/validator.valid&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; valid = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;exports.valid = valid;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意到上文中别名标签的值，这里用到一个叫做&lt;strong&gt;命名路径（namepaths）&lt;/strong&gt;的概念。这个概念表示使用 &lt;code&gt;#&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; &lt;code&gt;~&lt;/code&gt; 三种符号表示两个模块之间的从属关系，其分别为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#&lt;/code&gt; 实例属性，表示实例对象能够继承的属性；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt; 静态属性，普通对象的静态属性；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~&lt;/code&gt; 内部属性，在函数对象内部作用域定义的属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面这个例子分别解释了上面三种属性：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** @constructor */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.instanceSay = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;我是实例属性&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;innerSay&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;我是内部属性&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Person.staticSay = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;我是静态属性&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在注释中我们就可以使用这样的方式来表示上面三种属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Person#instanceSay&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Person.staticSay&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Person~innerSay&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面用命名路径生成的诸如 &lt;code&gt;Person#instanceSay.hello~hi&lt;/code&gt; 这样的引用名称就叫做&lt;strong&gt;长名（longname）&lt;/strong&gt;。其中如果是 &lt;code&gt;@module&lt;/code&gt; 模块的话，需要添加 &lt;code&gt;module:&lt;/code&gt; 前缀，用于与命名空间相区分。而命名空间的作用就是给其子属性开启一个可以被挂载的空间，可以在文档中被单独标记。子属性可以使用 &lt;code&gt;@memberof&lt;/code&gt; 对父属性进行挂载。比如我们挂载到全局变量上的属性，并不遵循模块化的风格，对其进行标记就可以使用命名空间的方式，如：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 某个文件中的祖先空间&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @namespace ancestor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ancestor = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.ancestor = ancestor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 某个文件中的父亲空间，挂载到祖先之下&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @namespace parent&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @memberof ancestor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; parent = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.ancestor.parent = parent;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 某个文件中的孩子空间，挂载到父亲之下，需要用长名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @namespace child&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @memberof ancestor.parent&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; child = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.ancestor.parent.child = child;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要注意的是，这种模块化的标签似乎 JSDoc 都会对其进行作用域的识别，因此在注释的时候一定要注意作用域的问题。比如对一个文件整个注释为 &lt;code&gt;@module&lt;/code&gt;，其内部的 &lt;code&gt;@namespace&lt;/code&gt; 可能就会失效，无法在文档上良好的反应。以下是模块化注释的常用标签：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;标签&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;@event&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在模板中标记可以被触发的事件，可与 &lt;code&gt;@fires&lt;/code&gt; 标签配合使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;@fires&lt;/code&gt; &lt;code&gt;@emit&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;模块通信触发事件描述，需要与 &lt;code&gt;@event&lt;/code&gt; 标签配合使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;@inner&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;模块内部变量标注&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;@memberof&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;标记模块之间的从属关系&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;@module&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;标记一个 CMD 或是 AMD 的模块&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;@namespace&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;开启命名空间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;@see&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;可以在文档中进行跳转，需要使用长名来进行连接&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;em&gt;参考链接&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jsdoc3/jsdoc&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jsdoc - Github&lt;/a&gt;： jsdoc npm module 的 Github 地址&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://usejsdoc.org/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jsdoc 官网&lt;/a&gt; ：jsdoc 官方文档&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;尽管一个好的项目文档能让项目增光添彩，但文档的作用始终是锦上添花而非雪中送炭，对于开发者来说，费尽心神的整理项目文档似乎也并非是一件令人愉快的事情。在使用题中所述的工具——jsdoc和编写本文的同时，笔者也是几度懊恼：这东西在项目中真的有用吗？是不是有点浪费时间？但随着项目体量的增大和开发人员的增多，使用并自动化维护一份好的文档所带来的优势也是逐渐显现。笔者也决心写一篇科普小文，说一说文档工具的使用注意要点。&lt;/p&gt;
    
    </summary>
    
      <category term="开发工具" scheme="http://malcolmyu.github.io/malnote/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="jsdoc" scheme="http://malcolmyu.github.io/malnote/tags/jsdoc/"/>
    
  </entry>
  
  <entry>
    <title>avalon 事件总线与依赖调度系统</title>
    <link href="http://malcolmyu.github.io/malnote/2015/04/19/Avalon-Event-Bus/"/>
    <id>http://malcolmyu.github.io/malnote/2015/04/19/Avalon-Event-Bus/</id>
    <published>2015-04-18T16:00:00.000Z</published>
    <updated>2015-11-27T07:31:47.000Z</updated>
    
    <content type="html">&lt;p&gt;在工作中经常使用到&lt;a href=&quot;http://www.cnblogs.com/rubylouvre/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;司徒&lt;/a&gt;的 &lt;a href=&quot;https://github.com/RubyLouvre/avalon&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;avalon&lt;/a&gt; ，由于坑点太多，有时需要经常查阅其源码实现。而 avalon 由于方兴未艾，网上对其进行源码解析的文章并不多，查了半天也就只有这篇 &lt;a href=&quot;http://www.cnblogs.com/sskyy/p/3679572.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MVVM 大比拼&lt;/a&gt;，以及这篇 &lt;a href=&quot;http://www.cnblogs.com/aaronjs/archive/2013/06/16/3138631.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;avalon 源码分析&lt;/a&gt;。个人认为这两篇文章写得都并不算好，其一是成文较早，研究的源码还是 1.2.5 版本，而目前的新版本已经到了 1.4+，比之前不知道高到哪里去。其二是大比拼一文作者阅码无数，心中早已无码，写分析只观其大要，似乎在和原作者谈笑风生；而后者的分析仿佛又只是对源码的粗略通读，也没怎么经过实践，有些图样图森破。因此自己决定安下心来写点源码分析。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;本文源起自同事的一个疑问，“&lt;em&gt;可否使用事件中的 &lt;code&gt;$fire&lt;/code&gt; 来改变一个普通双绑属性的值？&lt;/em&gt;”这样问也是有它的理由：因为在视图模型中，可以用 &lt;code&gt;$watch&lt;/code&gt; 来监听属性的变化；而在事件总线中，可以用 &lt;code&gt;$fire&lt;/code&gt; 来触发 &lt;code&gt;$watch&lt;/code&gt; 的回调，那似乎用 &lt;code&gt;$fire&lt;/code&gt; 来改变双绑属性的值也变得可以接受。但实际测试中，发现这样操作是不起作用的。如：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; demo = avalon.define(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $id: &lt;span class=&quot;string&quot;&gt;&#39;demo&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    a: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;demo.$fire(&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// nothing output&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这是为什么呢？起初我认为事件总线与依赖调度实际上是绑在一起的，也就是说双绑属性上的事件——如值改变后通知视图——也是通过事件总线来实现的；后来想到 avalon 师承 knockout，而事件是 angular 中才有的概念，可能是后来单独实现的也说不定。带着这样的疑问，我翻开了源码：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; EventBus = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $watch: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;type, callback&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; callback === &lt;span class=&quot;string&quot;&gt;&quot;function&quot;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; callbacks = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.$events[type]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (callbacks) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                callbacks.push(callback)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.$events[type] = [callback]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123; &lt;span class=&quot;comment&quot;&gt;//重新开始监听此VM的第一重简单属性的变动&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.$events = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.$watch.backup&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 省略了 unwatch 事件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $fire: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;type&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 这里对 $fire 处理 dom 层级关系的部分做了大量省略&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; callbacks = events[type] || []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; all = events.$all || []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; callback = callbacks[i++]; ) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isFunction(callback))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                callback.apply(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, args)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; callback = all[i++]; ) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isFunction(callback))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                callback.apply(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们可以看到，在源码中出现最多的东西就是这个 &lt;code&gt;$events&lt;/code&gt; 。上面两段代码的主要意思就是说，在 &lt;code&gt;$watch&lt;/code&gt; 的时候，查看一下当前层级的 &lt;code&gt;$event&lt;/code&gt; 中是否有对应名称的事件队列，在确保 &lt;code&gt;$watch&lt;/code&gt; 参数是函数的前提下将回调添加到事件队列中；而 &lt;code&gt;$fire&lt;/code&gt; 的时候需要遍历 &lt;code&gt;$event&lt;/code&gt; 对应的事件队列，取出是函数的部分执行它。&lt;/p&gt;
&lt;p&gt;这里就产生了一个疑问：我之前以为依赖调度的事件也是存放在 &lt;code&gt;$events&lt;/code&gt; 队列中的，比如上文的视图模型 demo，加入页面上有写了双绑的 a，如 &lt;code&gt;&amp;lt;span ms-if=&amp;quot;a&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&lt;/code&gt; 之类，那么 a 的依赖调度就是储存在 &lt;code&gt;demo.$events&lt;/code&gt; 中的。既然事件总线的回调也是储存在 &lt;code&gt;$events&lt;/code&gt; 中，那二者的实现方式又有何区别？&lt;/p&gt;
&lt;p&gt;继续翻到依赖调度系统的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;registerSubscriber&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;data&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Registry[expose] = data&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 暴光此函数,方便collectSubscribers收集&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; fn = data.evaluator&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (fn) &amp;#123; &lt;span class=&quot;comment&quot;&gt;//如果是求值函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; c = ronduplex.test(data.type) ? data : fn.apply(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, data.args)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        data.handler(c, data.element, data)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;collectSubscribers&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;list&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; data = Registry[expose]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 收集依赖于这个访问器的订阅者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (list &amp;amp;&amp;amp; data &amp;amp;&amp;amp; avalon.Array.ensure(list, data) &amp;amp;&amp;amp; data.element) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//只有数组不存在此元素才push进去&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        addSubscribers(data, list)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;notifySubscribers&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;list&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 通知依赖于这个访问器的订阅者更新自身&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (list &amp;amp;&amp;amp; list.length) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 省略了定时检查移除订阅和监控数组的代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = list.length, fn; fn = list[--i]; ) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; fun = fn.evaluator || noop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            fn.handler(fun.apply(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, fn.args || []), el, fn)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;过一遍依赖调度的代码我们会发现它的三个主要的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;registerSubscriber&lt;/code&gt; 用于给依赖调度系统曝光一个依赖。该方法是在智能代理 &lt;code&gt;parseExprProxy&lt;/code&gt; 中调用的，而这一方法是承自 avalon 的两大系统之一——&lt;strong&gt;扫描系统&lt;/strong&gt;——在扫描绑定的时候执行的，而参数 &lt;code&gt;data&lt;/code&gt; 就是扫描绑定生成的对象。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;collectSubscribers&lt;/code&gt; 用于收集访问器的订阅者。这个方法是在&lt;strong&gt;访问器（accessor）&lt;/strong&gt;中进行收集的，当一个属性被 get 的时候进行收集。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;notifySubscribers&lt;/code&gt; 通知依赖于这个访问器的订阅者更新自身。这个方法也是在访问器中进行收集的，对应了属性 set 的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于访问器是在模型工厂中被生成的，也就是说，&lt;strong&gt;依赖调度系统是链接 avalon 两大系统——扫描系统（scan）和模型工厂（define）的重要模块&lt;/strong&gt;，是将扫描页面产生的绑定与处理 viewModel 生成的属性结合起来的重要手段。&lt;/p&gt;
&lt;p&gt;这是依赖调度系统的功能，这一枝我们按下不表，有机会会开篇详述。我们关注的问题还是在于：为何依赖调度与事件总线都是通过 &lt;code&gt;$events&lt;/code&gt; 来进行处理，二者却花开两朵呢？&lt;/p&gt;
&lt;p&gt;对上面两个重要的方法进行再一次简化，得到如下的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;registerSubscriber&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;data&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Registry[expose] = data&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    data.evaluator.apply(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, data.args)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;collectSubscribers&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;list&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; data = Registry[expose]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    avalon.Array.ensure(list, data)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 &lt;code&gt;registerSubscriber&lt;/code&gt; 中，执行了一步求值函数。这时候就会触发访问器的 get 方法，继而触发 &lt;code&gt;collectSubscribers&lt;/code&gt;；而后者的参数就是对应的 &lt;code&gt;$events&lt;/code&gt;，在这里将刚才曝光的 &lt;code&gt;data&lt;/code&gt; 添加到 &lt;code&gt;$events&lt;/code&gt; 队列中。这里的 &lt;code&gt;data&lt;/code&gt; 不是回调函数，而是扫描绑定生成的数据，包含 DOM 节点、求值函数、vm等等。&lt;/p&gt;
&lt;p&gt;看到这里我们就明白了——尽管依赖调度和事件总线的内容都寄存在 &lt;code&gt;$events&lt;/code&gt; 中，但一个存的是对象，一个存的是回调函数，所以两者实际上走的是不同的处理路线。&lt;/p&gt;
&lt;p&gt;观察一下访问器的代码，证实了我们这一观点：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 这里只探究简单属性，故而对其进行了简化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;.length) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 有参数表示 set&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!isEqual(oldValue, newValue)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        $model[name] = newValue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        notifySubscribers($events[name]) &lt;span class=&quot;comment&quot;&gt;// 同步视图&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        safeFire($vmodel, name, newValue, oldValue) &lt;span class=&quot;comment&quot;&gt;// 触发$watch回调&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 无参数表示 get&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    collectSubscribers($events[name]) &lt;span class=&quot;comment&quot;&gt;// 收集视图函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; accessor.svmodel || oldValue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在访问器中，需要分别进行同步视图与触发 &lt;code&gt;$watch&lt;/code&gt; 回调的操作，分别处理了两个系统的事务。回到之前同事的问题：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; demo = avalon.define(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $id: &lt;span class=&quot;string&quot;&gt;&#39;demo&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    a: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;demo.$watch(&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;a&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;demo.$fire(&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// 输出2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;demo.a = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;         &lt;span class=&quot;comment&quot;&gt;// 输出3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于依赖调度与事件总线是两个不同的系统，因此 &lt;code&gt;$fire&lt;/code&gt; 只能触发事件总线中挂载在 a 上的回调，而无法触发访问器；而由于访问器中在 set 时对两个系统都进行了触发，因此可以即同步视图，又能触发事件回调，所以可以使用 &lt;code&gt;$watch&lt;/code&gt; 来监听属性值的变化。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在工作中经常使用到&lt;a href=&quot;http://www.cnblogs.com/rubylouvre/&quot;&gt;司徒&lt;/a&gt;的 &lt;a href=&quot;https://github.com/RubyLouvre/avalon&quot;&gt;avalon&lt;/a&gt; ，由于坑点太多，有时需要经常查阅其源码实现。而 avalon 由于方兴未艾，网上对其进行源码解析的文章并不多，查了半天也就只有这篇 &lt;a href=&quot;http://www.cnblogs.com/sskyy/p/3679572.html&quot;&gt;MVVM 大比拼&lt;/a&gt;，以及这篇 &lt;a href=&quot;http://www.cnblogs.com/aaronjs/archive/2013/06/16/3138631.html&quot;&gt;avalon 源码分析&lt;/a&gt;。个人认为这两篇文章写得都并不算好，其一是成文较早，研究的源码还是 1.2.5 版本，而目前的新版本已经到了 1.4+，比之前不知道高到哪里去。其二是大比拼一文作者阅码无数，心中早已无码，写分析只观其大要，似乎在和原作者谈笑风生；而后者的分析仿佛又只是对源码的粗略通读，也没怎么经过实践，有些图样图森破。因此自己决定安下心来写点源码分析。&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://malcolmyu.github.io/malnote/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Javascript" scheme="http://malcolmyu.github.io/malnote/tags/Javascript/"/>
    
      <category term="avalon" scheme="http://malcolmyu.github.io/malnote/tags/avalon/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Promise 探微</title>
    <link href="http://malcolmyu.github.io/malnote/2014/08/30/JavaScript-Promise-In-Wicked-Detail/"/>
    <id>http://malcolmyu.github.io/malnote/2014/08/30/JavaScript-Promise-In-Wicked-Detail/</id>
    <published>2014-08-29T16:00:00.000Z</published>
    <updated>2015-11-30T02:39:27.000Z</updated>
    
    <content type="html">&lt;p&gt;原文链接：&lt;a href=&quot;http://www.mattgreer.org/articles/promises-in-wicked-detail/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JavaScript Promises … In Wicked Detail&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我在 JavaScript 中使用 Promise 已经有一段时间了，目前我已经能高效的使用这一开始让我晕头转向的东西。但真要细说起来，我发现还是不能完全理解它的实现原理，这也正是本文写作的目的所在。如果诸位读者也处在一知半解的状态，那请读完这篇文章，相信你也会像我一样对 Promise 有更好的理解。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;我们将会循序渐进的建立一个 Promise 的实现，最终这个实现会基本符合 &lt;a href=&quot;http://promisesaplus.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Promise/A+ 规范&lt;/a&gt;，在此过程中你会逐步的了解到 Promise 是如何实现了异步编程的需求。本文假设你已经有了一定的 Promise 基础，如果你对此一无所知，请移步&lt;a href=&quot;https://www.promisejs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网&lt;/a&gt;先了解学习一下。&lt;/p&gt;
&lt;h1 id=&quot;为什么要写这篇文章？&quot;&gt;为什么要写这篇文章？&lt;/h1&gt;&lt;p&gt;有些童鞋会问：为啥我们要对 Promise 了解得这么细呢，会用不就好了么？其实理解了一个东西的实现机理，可以提升你使用它的能力和效率，同时在使用出错的时候能更有效地 debug —— 我之所以写这篇文章就是因为有一次和同事掉进一个关于 Promise 的奇怪的坑里去了。要是当年我就和现在这样了解得这么透彻，我就不会掉坑了~&lt;/p&gt;
&lt;h1 id=&quot;最简单的例子&quot;&gt;最简单的例子&lt;/h1&gt;&lt;p&gt;让我们从最简单的例子开始实现我们的 Promise 实例，我想将这样的写法：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;doSomething(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;value&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;Got a value:&#39;&lt;/span&gt; + value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实现为这样的写法：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;doSomething().then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;value&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;Got a value:&#39;&lt;/span&gt; + value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了实现这个效果，我们只需要将 &lt;code&gt;donSomething()&lt;/code&gt; 函数从这样的形式：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;doSomething&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;callback&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; value = &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  callback(value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;改成这种 “Promise” 基础版：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;doSomething&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    then: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;callback&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; value = &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      callback(value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种写法只是给我们的回调模式写了一个简单且毫无意义的语法糖。我们目前还没有触及 Promise 背后的核心概念，但这也是个小小的开始。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Promise 可以捕获最终值（the eventual value）这一概念并将其置入对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这正是 Promise 的有趣之处（&lt;strong&gt;译者注：&lt;/strong&gt;所谓的最终值，实际上是规范里面的一个概念，表示异步操作的最终获取值。实际上上面这句话的意思就是将我们要传给回调函数的终值也保存在 Promise 对象里）。在后面的探索中，我们就会发现：一旦最终值的概念可以被这样捕获到，我们就可以干一些非常给力的事情。&lt;/p&gt;
&lt;h2 id=&quot;定义_Promise_类型&quot;&gt;定义 Promise 类型&lt;/h2&gt;&lt;p&gt;让我们进行下一步，定义一个实际的 &lt;code&gt;Promise&lt;/code&gt; 类型来扩展上面的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;fn&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; callback = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.then = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;cb&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    callback = cb;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;resolve&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;value&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    callback(value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  fn(resolve);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后用 Promise 类型重写 &lt;code&gt;doSomething()&lt;/code&gt; 函数：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;doSomething&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;resolve&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; value = &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    resolve(value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里就遇到一个问题：如果你逐行执行代码，就会发现 &lt;code&gt;resolve()&lt;/code&gt; 函数在 &lt;code&gt;then()&lt;/code&gt; 函数之前被调用，这就意味着 &lt;code&gt;resolve()&lt;/code&gt; 被调用的时候，&lt;code&gt;callback&lt;/code&gt; 还是 &lt;code&gt;null&lt;/code&gt; 。让我们用一个 hack 来干掉这个问题，引入 &lt;code&gt;setTimeout&lt;/code&gt;，代码如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;fn&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; callback = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.then = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;cb&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    callback = cb;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;resolve&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;value&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将 callback 打出当前执行线程，使之可以被 then 函数设定&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      callback(value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  fn(resolve);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;用了这么个毛招，我们的代码终于可以运行啦=。=&lt;/p&gt;
&lt;h2 id=&quot;这个代码太毛啦&quot;&gt;这个代码太毛啦&lt;/h2&gt;&lt;p&gt;我们写的图样图森破的 Promise 必须要加入异步操作才能工作，这很容易使之再次失效。只要异步地调用 &lt;code&gt;then()&lt;/code&gt; 函数，我们的 callback 又会马上变成 &lt;code&gt;null&lt;/code&gt; 了。有作死的读者可能会问：为啥我要写出这么一个破代码让我这么快就感受到失败的挫折？因为我想用上面这个简单易懂的例子将 Promise 的两大关键概念—— &lt;code&gt;then()&lt;/code&gt; 和 &lt;code&gt;resolve()&lt;/code&gt; 深深地烙印在你的脑海中。它们会阴魂不散地跟随着你哟~&lt;/p&gt;
&lt;h1 id=&quot;Promise_是有状态（state）的&quot;&gt;Promise 是有状态（state）的&lt;/h1&gt;&lt;p&gt;我们糟糕易崩溃代码暴露了一个之前我们没有想到的问题—— Promise 是具有状态的。我们在运行之前需要知道其当前所处的状态，并确保我们可以正确地进行状态转换。采用这种方式可以让我的代码稳定性强一些。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;promise 可以处在等待被赋值的&lt;strong&gt;等待态（pending）&lt;/strong&gt;，可以被给予一个值并转为&lt;strong&gt;解决态（resolved）&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;一旦 promise 被一个值 resolve 掉，其就会一直保持这个值并不会再被 resolve。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;（一个 promise 对象也可以被&lt;strong&gt;拒绝 rejected&lt;/strong&gt;，我们在稍后的错误处理中会提到）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;让我们在实例中加入状态的跟踪，以此摆脱之前的毛招：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;fn&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; state = &lt;span class=&quot;string&quot;&gt;&#39;pending&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; deferred;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;resolve&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;newValue&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    value = newValue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    state = &lt;span class=&quot;string&quot;&gt;&#39;resolved&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(deferred) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      handle(deferred);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;handle&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;onResolved&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(state === &lt;span class=&quot;string&quot;&gt;&#39;pending&#39;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      deferred = onResolved;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    onResolved(value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.then = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;onResolved&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    handle(onResolved);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  fn(resolve);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们的代码变得更加复杂，但是这样就使得 Promise 对象调用者可以随时激活 &lt;code&gt;then()&lt;/code&gt; 函数，被调用的 Promise 对象也可以随时激活 &lt;code&gt;resolve()&lt;/code&gt; 方法。这在异步和同步的代码中都是完全适用的。&lt;/p&gt;
&lt;p&gt;这正是 &lt;code&gt;state&lt;/code&gt; 标志的功劳。新方法 &lt;code&gt;handle()&lt;/code&gt; 与之前的两个重要概念 &lt;code&gt;then()&lt;/code&gt; 和 &lt;code&gt;resolve()&lt;/code&gt; 互不干涉，其将会根据情况在以下两种操作中选择一种执行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;then()&lt;/code&gt; 在 &lt;code&gt;resolve()&lt;/code&gt; 之前先被调用，意味着还没有最终值传递给回调函数。这种状态下即为等待态，我们便在内存中保存回调函数以便后续使用。当 &lt;code&gt;resolve()&lt;/code&gt; 被调用时，我们激活回调函数并将终值传入。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reslove&lt;/code&gt; 在 &lt;code&gt;then()&lt;/code&gt; 之前被调用，这种情况下我们将终值保存在内存中，一旦 &lt;code&gt;then()&lt;/code&gt; 被调用，我们就将终值传入。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意到 &lt;code&gt;setTimeout&lt;/code&gt; 不见了么，这个只是暂时的，它还会回来哒~&lt;/p&gt;
&lt;p&gt;言归正传：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用 promises 的时候，我们调用其方法的顺序并不重要，可以按照自己的意愿随时调用 &lt;code&gt;then()&lt;/code&gt; 和 &lt;code&gt;resolve()&lt;/code&gt;，这就是将终值捕获并置于对象之中保存的强大优势。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;尽管我们还有一些事情米有做，我们的 promises 已经非常给力了。这套实现允许我们执行多次 &lt;code&gt;then()&lt;/code&gt; —— 其每次都会获取到同样的终值。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; promise = doSomething();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;promise.then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;value&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;Got a value:&#39;&lt;/span&gt;, value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;promise.then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;value&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 此处获取的值和上一处相同&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;Got the same value again:&#39;&lt;/span&gt;, value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;（其实吧……这个地方并不是完全正确的，如果我们反过来操作，在执行 &lt;code&gt;resolve()&lt;/code&gt; 之前多次执行 &lt;code&gt;then()&lt;/code&gt; ，结果只有最后一次的执行会成功。如果要修复这个问题需要在 Promise 对象中维护一个队列来记录回调函数。但由于这篇文章已经够长了，所以我决定不这么搞了=v=）&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;通通连起来吧&quot;&gt;通通连起来吧&lt;/h1&gt;&lt;p&gt;既然 Promise 将异步操作捕获到了对象中，我们就可以对其进行链式操作、map 操作以及串行并行等等其他高效率的操作。下列代码就是一个非常常见的 Promise 用法：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;getSomeData()  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .then(filterTheData)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .then(processTheData)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .then(displayTheData);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于可以调用 &lt;code&gt;then()&lt;/code&gt; 函数，这证明 &lt;code&gt;getSomeData()&lt;/code&gt; 返回的是一个 promise 对象；但是第一个怎返回的结果页必须是一个 promise 对象，然后我们才能再次调用 &lt;code&gt;then()&lt;/code&gt; 函数（然后再次调用再次调用再次调用~）。而实际的 Promise 实现就是这样的效果，假如我们能够让 &lt;code&gt;then()&lt;/code&gt; 函数返回一个 promise 对象，一切就变得更有趣起来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;then()&lt;/code&gt; 永远返回一个 promise 对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下就是给我们的 promise 假如链式调用的情况：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;fn&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; state = &lt;span class=&quot;string&quot;&gt;&#39;pending&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; deferred = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;resolve&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;newValue&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    value = newValue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    state = &lt;span class=&quot;string&quot;&gt;&#39;resolved&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(deferred) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      handle(deferred);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;handle&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;handler&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(state === &lt;span class=&quot;string&quot;&gt;&#39;pending&#39;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      deferred = handler;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!handler.onResolved) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      handler.resolve(value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ret = handler.onResolved(value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    handler.resolve(ret);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.then = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;onResolved&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;resolve&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      handle(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        onResolved: onResolved,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        resolve: resolve&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  fn(resolve);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;额……已经变得有点令人抓狂啦，你是不是在庆幸我们进展的比较缓慢呢~这里的关键之处就在于：&lt;code&gt;then()&lt;/code&gt; 函数返回了一个&lt;strong&gt;新的 Promise 对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（由于 &lt;code&gt;then()&lt;/code&gt; 永远返回一个新的 promise 对象，导致每次都至少有一个 promise 对象被创建、解决然后被忽略，这就产生了一定程度了内存浪费。这是 Promise 被诟病的一个原因，因为传统的回调金字塔就不存在这样的问题。由此你可以理解为啥一些 JavaScript 社区已经抛弃了 promise ）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;那第二个 promise 要 resolve 的值是什么呢？答案是：&lt;strong&gt;第一个 promise 的返回值&lt;/strong&gt;。 &lt;code&gt;handle()&lt;/code&gt; 函数的最后两行体现了这一点， &lt;code&gt;handler&lt;/code&gt; 对象保存了 &lt;code&gt;onResolved()&lt;/code&gt; 回调函数和 &lt;code&gt;resolve()&lt;/code&gt; 函数的引用。在链式调用中保存了多个 &lt;code&gt;resolve()&lt;/code&gt; 函数的拷贝，每一个 promise 对象的内部都拥有一个自己的 &lt;code&gt;resolve()&lt;/code&gt; 方法，并在闭包中运行。 这建立起了第一个 promise 与第二个 promise 之间联系的桥梁。我们在这一行代码 resolve 了第一个 promise：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ret = handler.onResolved(value);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在上文的例子中，程序里的 &lt;code&gt;handler.onResolved&lt;/code&gt; 是这个函数：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;value&lt;/span&gt;) &lt;/span&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;Got a value:&#39;&lt;/span&gt;, value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;换句话说，这就是我们第一次调用 &lt;code&gt;then()&lt;/code&gt; 时传入的处理函数，第一个处理函数的返回值将会用来传递给第二个 promise，链式调用就这么完成啦~&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;doSomething().then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;result&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;first result&#39;&lt;/span&gt;, result);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;88&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;secondResult&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;second result&#39;&lt;/span&gt;, secondResult);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 输出结果是：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 第一个结果：42&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 第二个结果：88&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;doSomething().then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;result&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;first result&#39;&lt;/span&gt;, result);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 没有显示的返回值（也就是 undefined）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;secondResult&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;second result&#39;&lt;/span&gt;, secondResult);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 输出结果是：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 第一个结果：42&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 第二个结果：undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;既然 &lt;code&gt;then()&lt;/code&gt; 方法永远返回一个新的 promise ，因此这个链式调用就可以越链越深：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;doSomething().then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;result&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;first result&#39;&lt;/span&gt;, result);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;88&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;secondResult&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;second result&#39;&lt;/span&gt;, secondResult);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;thirdResult&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;third result&#39;&lt;/span&gt;, thirdResult);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;fourthResult&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 链呀链...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们如果想在上面的例子中获取每次处理函数调用返回的结果集，就必须在链式调用中人工构建一个存放结果集的数组：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;doSomething().then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;result&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; results = [result];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  results.push(&lt;span class=&quot;number&quot;&gt;88&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; results;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;results&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  results.push(&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; results;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;results&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(results.join(&lt;span class=&quot;string&quot;&gt;&#39;, &#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 输出结果：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 42, 88, 99&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Promise 每次只会 resolve 一个值，如果你想传递多个值，就需要建立一种存储方式来进行传递（如数组、对象和字符串）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更好的解决途径是使用 Promise 库中的 &lt;code&gt;all()&lt;/code&gt; 方法或其他实用的方法来提升 promise 的使用效率，这就有待诸位读者自己挖掘啦。&lt;/p&gt;
&lt;h2 id=&quot;可选的回调函数&quot;&gt;可选的回调函数&lt;/h2&gt;&lt;p&gt;&lt;code&gt;then()&lt;/code&gt; 中的回调函数并不是严格要求必写的，加入你不写这个回调， promise 也会用上一个 promise 返回的终值来传递。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;doSomething().then().then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;result&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;got a result&#39;&lt;/span&gt;, result);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 输出结果是：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// got a result 42&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你可以在 &lt;code&gt;handle()&lt;/code&gt; 函数内部观察到这个情况，如果当前的 &lt;code&gt;then()&lt;/code&gt; 没有传递回调函数，该函数就会直接使用前一个 promise 返回的终值来解决下一个 promise：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!handler.onResolved) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  handler.resolve(value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;链中返回_promise&quot;&gt;链中返回 promise&lt;/h2&gt;&lt;p&gt;我们实现链式的实例还是略显简单，其仅仅是将解决终值传递下去，但如果有个终值就是 promise 咋办？举个栗子：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;doSomething().then(result) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// doSomethingElse 返回一个 promise&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; doSomethingElse(result)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;.then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;finalResult&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;the final result is&quot;&lt;/span&gt;, finalResult);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;目前来看，上面的结果不会是我们期望的那样。&lt;code&gt;finalResult&lt;/code&gt; 不会是的第一个 result 的值，而会是一个 promise 对象。为了达到我们期望的结果（也就是依然让返回值传递下去），我们需要这样做：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;doSomething().then(result) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// doSomethingElse 返回一个 promise&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; doSomethingElse(result)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;.then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;anotherPromise&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  anotherPromise.then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;finalResult&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;the final result is&quot;&lt;/span&gt;, finalResult);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;    
&lt;p&gt;=。=但是你会让这一坨翔一样的代码出现在你的项目中么…让我们在 promise 实例中隐式的处理掉这个问题。这个处理方式还是比较简单的，只要在 &lt;code&gt;resolve()&lt;/code&gt; 方法中加入一个对返回值是 promise 对象的特殊处理就行啦：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;resolve&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;newValue&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(newValue &amp;amp;&amp;amp; &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; newValue.then === &lt;span class=&quot;string&quot;&gt;&#39;function&#39;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    newValue.then(resolve);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  state = &lt;span class=&quot;string&quot;&gt;&#39;resolved&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  value = newValue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(deferred) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    handle(deferred);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样我们就可以继续持续的调用 &lt;code&gt;resolve()&lt;/code&gt; 直到我们获取到一个 promise。当其返回值不是 promise 对象时，调用链就会和之前一样正常执行。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这样的话可能会造成无穷回路（&lt;strong&gt;译者注：&lt;/strong&gt;也就是 &lt;code&gt;then()&lt;/code&gt; 返回 promise 对象然后又调用 &lt;code&gt;then()&lt;/code&gt;）。尽管 A+ 规范里建议 promise 的实现中对无穷回路进行判断，但这种判断是没什么必要的（&lt;strong&gt;译者注：&lt;/strong&gt;在规范的最后写了说明，规范本身建议判断，但 promise 的实现并不建议判断）。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;另外，我们这个实现实际上并不完全符合规范，这篇文章里说的东西也没有完全符合规范。假如你对规范本身感兴趣，请移步文章开始处的规范链接。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;有没有注意到我们对于 &lt;code&gt;newValue&lt;/code&gt; 是否为 promise 对象的检测是多么的宽松么，我们只是判断它是否拥有 &lt;code&gt;then()&lt;/code&gt; 方法。这个鸭子类型是我故意这么写的（&lt;strong&gt;译者注：&lt;/strong&gt;这不是一个 bug，这是个 feature）！这使得不同的 promise 实现可以相互运作，实际上这也是不同的第三方 promise 库的比较常见的混用方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不同的 promise 实现只要恰当的遵循规范，就可以相互混用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;搞定了链式调用之后，我们的实现基本接近完成，除了最初被我们完全忽略掉的一个问题 —— &lt;strong&gt;错误处理&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&quot;Promise_的拒绝（reject）&quot;&gt;Promise 的拒绝（reject）&lt;/h1&gt;&lt;p&gt;当一个 promise 运行发生错误，其需要被&lt;strong&gt;拒绝（reject）&lt;/strong&gt;并传入一个&lt;strong&gt;原因（reason）&lt;/strong&gt;。那么调用者怎么知道何时进行 reject 呢？这可以通过给 &lt;code&gt;then()&lt;/code&gt; 函数的第二个参数传入回调来实现。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;doSomething().then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;value&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;Success!&#39;&lt;/span&gt;, value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;error&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;Uh oh&#39;&lt;/span&gt;, error);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;正如之前所提到的那样，promise 对象可以从 pending 转换到 resolved 或者 rejected，但不能同时 resolved 和 rejected。换言之，&lt;code&gt;then&lt;/code&gt; 的两个回调中仅有一个会被调用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Promise 可以通过 &lt;code&gt;resolve()&lt;/code&gt; 方法的孪生兄弟 —— &lt;code&gt;reject()&lt;/code&gt; 方法来实现拒绝。下面是给 &lt;code&gt;doSomething()&lt;/code&gt; 加入错误处理的情况：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;doSomething&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;resolve, reject&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; result = somehowGetTheValue();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(result.error) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      reject(result.error);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      resolve(result.value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在我们 promise 的实现中，我们也必须考虑到 reject 。一旦一个 promise 被拒绝，其后面的调用链中的 promise 也必须被拒绝。&lt;/p&gt;
&lt;p&gt;让我们再来一起看一下完成版的 promise 实例的实现，这其中加入了拒绝的处理。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;fn&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; state = &lt;span class=&quot;string&quot;&gt;&#39;pending&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; deferred = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;resolve&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;newValue&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(newValue &amp;amp;&amp;amp; &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; newValue.then === &lt;span class=&quot;string&quot;&gt;&#39;function&#39;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      newValue.then(resolve, reject);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    state = &lt;span class=&quot;string&quot;&gt;&#39;resolved&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    value = newValue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(deferred) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      handle(deferred);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;reject&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;reason&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    state = &lt;span class=&quot;string&quot;&gt;&#39;rejected&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    value = reason;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(deferred) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      handle(deferred);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;handle&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;handler&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(state === &lt;span class=&quot;string&quot;&gt;&#39;pending&#39;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      deferred = handler;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; handlerCallback;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(state === &lt;span class=&quot;string&quot;&gt;&#39;resolved&#39;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      handlerCallback = handler.onResolved;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      handlerCallback = handler.onRejected;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!handlerCallback) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(state === &lt;span class=&quot;string&quot;&gt;&#39;resolved&#39;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        handler.resolve(value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        handler.reject(value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ret = handlerCallback(value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    handler.resolve(ret);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.then = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;onResolved, onRejected&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;resolve, reject&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      handle(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        onResolved: onResolved,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        onRejected: onRejected,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        resolve: resolve,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        reject: reject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  fn(resolve, reject);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;除去额外加入的 &lt;code&gt;reject()&lt;/code&gt; 函数，&lt;code&gt;handle()&lt;/code&gt; 函数本身也能对拒绝进行应对。其根据 &lt;code&gt;state&lt;/code&gt; 的值来决定进行 resolve 还是 reject，而后 &lt;code&gt;state&lt;/code&gt; 的值会被推送到下一个 promise 中，作为决定下个 promise 进行解决还是拒绝的依据（&lt;strong&gt;译者注：&lt;/strong&gt;在这个实现中，并没有体现出这一点。因为本实例使用的是 &lt;code&gt;then()&lt;/code&gt; 链而不是 &lt;code&gt;done()&lt;/code&gt;  &lt;code&gt;fail()&lt;/code&gt; 链，每次传递的都是一个新的 promise 对象，因此上一个 promise 被拒绝了，也仅仅会把其拒绝回调函数的返回值传递给下一个链的 resolve 回调。言下之意，本实例中的只有第一个 promise 对象可以被拒绝，第二个起直到链尾的 promise 其拒绝回调都无法被调用 —— 除非发生下一章节的非预期异常，有兴趣的读者可以自己试一试）。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;当使用 promise 的时候，我们很容易把错误处理的回调省略掉，但这样会导致我们无法捕获到任何报错。你至少应该在链式 promise 的最后写一个错误处理回调。这里可以参加下一章的错误吞没。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;非预期的错误也应该被拒绝&quot;&gt;非预期的错误也应该被拒绝&lt;/h2&gt;&lt;p&gt;目前我们处理的错误仅仅是已知的错误，但也可能突然蹦出来一个意料之外的错误然后把一切搞崩掉。因此 promise 实例对这些异常进行捕获并拒绝也是十分必要的。&lt;/p&gt;
&lt;p&gt;这就意味着 &lt;code&gt;resolve()&lt;/code&gt; 方法需要被包裹在 try/catch 语句块中：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;resolve&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;newValue&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ... 这里和以前一样&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt;(e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    reject(e);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;保证 &lt;code&gt;then()&lt;/code&gt; 中传入的回调函数不会抛出一些无法处理的异常也很重要。由于这些回调在 &lt;code&gt;handle()&lt;/code&gt; 中被调用，因此我们最终的实现结果是这样的：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;handle&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;deferred&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// ... 一切如前&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ret;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ret = handlerCallback(value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt;(e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    handler.reject(e);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  handler.resolve(ret);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;promises_可能吞没错误！&quot;&gt;promises 可能吞没错误！&lt;/h2&gt;&lt;p&gt;（&lt;strong&gt;译者注：&lt;/strong&gt;非常怀疑作者在文章开头掉进的大坑就是这个“错误吞噬”。）&lt;/p&gt;
&lt;p&gt;&lt;em&gt;对于 promises 的误解可能会导致报错信息的丢失。这是一个不少人都会掉进去的大坑。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我们看下面这个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getSomeJson&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;resolve, reject&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; badJson = &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;div&amp;gt;这东西根本不是JSON呀！&amp;lt;/div&amp;gt;&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    resolve(badJson);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getSomeJson().then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;json&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj = &lt;span class=&quot;built_in&quot;&gt;JSON&lt;/span&gt;.parse(json);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;error&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;uh oh&#39;&lt;/span&gt;, error);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里会发生什么事情呢？我们在 &lt;code&gt;then()&lt;/code&gt; 中传递的回调函数期望获得一个有效的 JSON 串，并用原生方法去解析它，因此导致了一个异常。但是我们有一个处理错误的回调函数（也就是 reject 回调），所以是不是米有问题呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大错特错。&lt;/strong&gt; reject 回调根本不会被调用到！如果你执行上述例子，你不会得到任何的输出。万籁此俱寂，没有错误输出，啥都米有。&lt;/p&gt;
&lt;p&gt;为什么会这样呢？因为未经处理的异常在我们 &lt;code&gt;then()&lt;/code&gt; 函数传入的回调中发生了，这在我们的实例中被 &lt;code&gt;handle()&lt;/code&gt; 捕获到。这导致 &lt;code&gt;handle()&lt;/code&gt; 拒绝的 promise 是这个 &lt;code&gt;then()&lt;/code&gt; 函数返回的那个 promise，而不是当前的我们准备进行错误处理的 promise ，而当前这个 promise 已经被 resolve 掉了。&lt;/p&gt;
&lt;p&gt;如果你想捕获上述的异常，你需要再链一个 &lt;code&gt;then()&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;getSomeJson().then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;json&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj = &lt;span class=&quot;built_in&quot;&gt;JSON&lt;/span&gt;.parse(json);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).then(&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;error&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;an error occured: &quot;&lt;/span&gt;, error);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在我们能正确的打印错误啦。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;根据我这么多年使用 promise 的经验，错误吞噬这东西是 promise 最大的坑了（&lt;strong&gt;译者注：&lt;/strong&gt;果然是作者掉的那个坑=。=），请阅读下一章节发现更好的解决方案—— &lt;code&gt;done()&lt;/code&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;救世者_done()&quot;&gt;救世者 &lt;code&gt;done()&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;大多数的 promise 库中都集成了 &lt;code&gt;done()&lt;/code&gt; 方法。它与 &lt;code&gt;then()&lt;/code&gt; 十分类似，但他避免了上述陷阱。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;done()&lt;/code&gt; 函数可以和 &lt;code&gt;then()&lt;/code&gt; 函数一样被调用，其差异之处在于它不会返回一个 promise 对象，且在 &lt;code&gt;done()&lt;/code&gt; 中未经处理的异常不会被 promise 实例所捕获。换句话说，当整个 promise 链被完全解决时才会调用 &lt;code&gt;done()&lt;/code&gt;。我们的 &lt;code&gt;getSomeJson()&lt;/code&gt; 的例子可以使用 &lt;code&gt;done()&lt;/code&gt; 来让之变得更加健壮。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;getSomeJson().done(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;json&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 当抛出异常时不会被吞没&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj = &lt;span class=&quot;built_in&quot;&gt;JSON&lt;/span&gt;.parse(json);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;   
&lt;p&gt;&lt;code&gt;done()&lt;/code&gt; 函数也和 &lt;code&gt;then()&lt;/code&gt; 一样有一个错误回调， &lt;code&gt;done(callback, errback)&lt;/code&gt;，当整个 promise 链被执行完成后，你可以保证任何抛出的异常都在错误回调中被捕获。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;code&gt;done()&lt;/code&gt; 目前为止还没有加入 promise/A+ 规范，所以某些 promise 库可能并不包含此功能。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;（&lt;strong&gt;译者注：&lt;/strong&gt;实际上这里作者所叙述的 &lt;code&gt;done()&lt;/code&gt; 和我们熟悉的 jQuery 里面实现的 &lt;code&gt;done()&lt;/code&gt; 并不相同。jQuery 用 Callback 对象实现的 &lt;code&gt;done()&lt;/code&gt; 方法，只能传递一个成功回调函数，且其返回的不是一个新的 promise 对象，而是当前的 promise 对象。）&lt;/p&gt;
&lt;h1 id=&quot;Promise_解决程序需要异步调用&quot;&gt;Promise 解决程序需要异步调用&lt;/h1&gt;&lt;p&gt;在文章的开始我们使用 &lt;code&gt;setTimeout&lt;/code&gt; 搞了一个毛招，当我们用“状态”这一概念解决掉这个毛招之后，我们就再未曾再见到过 &lt;code&gt;setTimeout&lt;/code&gt; 了呢。但实际上 Promise/A+ 规范要求 promise 的解决程序必须是异步的。为了符合这个小需求，我们只需简单的将 &lt;code&gt;handle()&lt;/code&gt; 方法中的大部分实现包裹在 &lt;code&gt;setTimeout&lt;/code&gt; 中即可。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;handle&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;handler&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(state === &lt;span class=&quot;string&quot;&gt;&#39;pending&#39;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    deferred = handler;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ... 一切如前&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上就是我们所需要做的事情。事实上真正的 promise 库不必非使用 &lt;code&gt;setTimeout&lt;/code&gt;。如果 promise 库是基于 NodeJS 的，那可能会用到 &lt;code&gt;process.nextTick&lt;/code&gt;；如果基于前端浏览器可能会用到最新的 &lt;code&gt;setImmediate&lt;/code&gt; 或是 &lt;a href=&quot;https://github.com/YuzuJS/setImmediate&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;setImmediate shim&lt;/a&gt; （因为迄今为止只有 IE 支持 &lt;code&gt;setImmediate&lt;/code&gt;），或者可能是一个异步的函数库，如 Kris Kowal 的 &lt;a href=&quot;https://github.com/kriskowal/asap&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;asap&lt;/a&gt;（此人还写了一个著名的 promise 库 —— &lt;a href=&quot;https://github.com/kriskowal/q&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Q&lt;/a&gt;）。&lt;/p&gt;
&lt;h2 id=&quot;为何在规范里要求异步调用？&quot;&gt;为何在规范里要求异步调用？&lt;/h2&gt;&lt;p&gt;这是为了保证一致性和可靠的执行流程，例如下面这个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; promise = doAnOperation();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;invokeSomething();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;promise.then(wrapItAllUp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;invokeSomethingElse();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里的执行流程会是怎样的呢？根据函数命名我们猜测应该是这样&lt;code&gt;invokeSomething()&lt;/code&gt; -&amp;gt; &lt;code&gt;invokeSomethingElse()&lt;/code&gt; -&amp;gt; &lt;code&gt;wrapItAllUp&lt;/code&gt;。但这其实完全取决于你当前实现的 promise 的解决方式是同步的还是异步的。如果 &lt;code&gt;doAnOperation()&lt;/code&gt; 是异步的，那其执行顺序就和我们猜测的一样；如果它是同步执行的，实际的执行顺序就会是这样：&lt;code&gt;invokeSomething()&lt;/code&gt; -&amp;gt; &lt;code&gt;wrapItAllUp&lt;/code&gt; -&amp;gt; &lt;code&gt;invokeSomethingElse()&lt;/code&gt;，这可能就会出现问题。&lt;/p&gt;
&lt;p&gt;为了处理这种情况， 即使异步不是必须的，但 &lt;strong&gt;promise 的解决程序也必须是异步的&lt;/strong&gt;。这减少了不必要的困扰，也让使用者在使用过程中不必考率代码里的异步实现。&lt;/p&gt;
&lt;h1 id=&quot;总结&quot;&gt;总结&lt;/h1&gt;&lt;p&gt;能读到这里你也是挺给力的……本文涵盖了规范中所要求的 promise 的核心实现，但大多数的 promise 库都提供了更多的功能，如 &lt;code&gt;all()&lt;/code&gt; 、&lt;code&gt;spread()&lt;/code&gt; 、&lt;code&gt;race()&lt;/code&gt; 、&lt;code&gt;denodeify()&lt;/code&gt; 等等。如果想了解 promise 的更多功能，我建议诸位看看 Bluebird 函数库的 &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;API&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在我了解了 promise 的运作方式和可能的坑之后，我爱上了 promise =v=。她让我们的代码变得非常整洁和优雅。当然这篇文章仅仅是个开始，对于 promise 而言，能够讨论的东西还有太多太多。&lt;/p&gt;
&lt;p&gt;如果你喜欢这篇文章，你可以在我的 &lt;a href=&quot;http://twitter.com/cityfortyone&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;twitter&lt;/a&gt; 上关注我一下，当我有别的更新的时候你也能及时发现~&lt;/p&gt;
&lt;h1 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.promisejs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;promisejs.org&lt;/a&gt; 文本中多次提到的 promises 教学&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/kriskowal/q/blob/v1/design/README.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Q  的基本设计原理&lt;/a&gt; 形式上和本文差不多的一篇文章，但细节上更加深入。作者就是 Q 之父 Kris Kowal。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/domenic/promises-unwrapping/issues/19&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;有关 done() 大法好不好的争论&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://solutionoptimist.com/2013/12/27/javascript-promise-chains-2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;扁平化的链式 Promise&lt;/a&gt; 作者是 Thomas Burleson，一篇给力的文章探讨 promise 的进阶用法。如果本文主要讲了什么是 promise，那这篇文章就更多的围绕为什么这样实现来展开。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;原文链接：&lt;a href=&quot;http://www.mattgreer.org/articles/promises-in-wicked-detail/&quot;&gt;JavaScript Promises … In Wicked Detail&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我在 JavaScript 中使用 Promise 已经有一段时间了，目前我已经能高效的使用这一开始让我晕头转向的东西。但真要细说起来，我发现还是不能完全理解它的实现原理，这也正是本文写作的目的所在。如果诸位读者也处在一知半解的状态，那请读完这篇文章，相信你也会像我一样对 Promise 有更好的理解。&lt;/p&gt;
    
    </summary>
    
      <category term="技术研究" scheme="http://malcolmyu.github.io/malnote/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Javascript" scheme="http://malcolmyu.github.io/malnote/tags/Javascript/"/>
    
      <category term="Promise" scheme="http://malcolmyu.github.io/malnote/tags/Promise/"/>
    
      <category term="翻译" scheme="http://malcolmyu.github.io/malnote/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>
